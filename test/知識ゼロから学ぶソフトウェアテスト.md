# 知識ゼロから学ぶソフトウェアテスト 第3版 アジャイル・AI時代の必携教科書

## 第1章　はじめに

### テスト担当者の心得

- バグを全部見つけるのは無理だと心得ろ！
- エラーは見つからないだろうという仮定のもとにテスト計画を立ててはいけない
- プログラムのある部分でエラーがまだ存在している確率は、すでにその部分で見つかったエラーの数に比例する
- ソフトウェアテストで重要なのは、どの部分にバグが出やすいのか、そこをどのようなテスト手法を適用すれば十分な品質が得られるかを知ることである

### 完全無欠なソフトウェアテストは可能か？

- まったくバグのないソフトウェアは存在しない
  - たくさんのテストケースを実行してもすべてはカバーできない
  - 品質向上のための投資は、投資額が修正にかかる費用を超過するか、「もっとましなことをすべきだ」と誰かが言い出すまで増加し続ける
- 例題：ユーザーが3つの整数を入力。整数は3角形の返の長さ。不等辺三角形、二等辺三角形、正三角形を判定するプログラムのテストケースを書く
  - 有効な不等辺三角形をテストする
  - 有効な正三角形をテストする
  - 有効な二等辺三角形をテストする
  - 有効な二等辺三角形で3種類の辺の組合せをテストする
  - 1辺の長さがゼロの値をテストする
  - 1辺の長さが負の値をテストする
  - 2辺の和がもう1辺と同じである
  - 2辺の和がもう1辺より小さい
  - すべての辺の長さがゼロ
  - 入力の個数が間違っている
  - それぞれのテストケースに対してその出力が正しいかをチェックする

## 第2章　ソフトウェアテストの基本 ―ホワイトボックステスト―

### ホワイトボックステスト

- プログラムの論理構造が正しいかを解析するテスト
  - 論理構造の正しさをテスト
  - ソフトウェアの仕様が間違っていることが原因のバグは発見できない
  - 昔：開発者がホワイトボックステスト（網羅率）／テスト担当がブラックボックステスト
  - 現在：担当者の境界はあいまいに

### 制御パステスト法

- プログラムがどのような振る舞いをして、どのように制御・実行されていくかをテストする
  - 網羅率を測定する
  - 基礎的かつ必須の手法
  - フローチャートをすべてカバーするイメージ

- 制御パステスト
  - ステートメントカバレッジ
    - コード内の命令文を少なくとも1回は実行する
    - 比較的弱いテスト（見つかるバグは限られる）
  - ブランチカバレッジ
    - 分岐コードに対し、判定条件がtrue/falseの結果を少なくとも1回は実行する
    - 境界値で確認するのが有効
  - ステートメント＋ブランチカバレッジを最低限実行すること

### カバレッジ基準

- 80%（60%～90%）程度を作者は推奨
- Google基準
  - 60%：許容範囲(Acceptable)
  - 75%：推奨(Commendable)
  - 90%：模範的(Exemplary)
  - 低いカバレッジは、大きいエリアテストがされていない
  - 高いカバレッジだから品質が高いわけではない
  - よく変更されるコードは網羅されるべき
  - レガシーコードのカバレッジを放っておくのはいいけれど、少しずつ網羅率を上げていきましょう

### カバレッジテストで検出できないバグ

- プログラムのループに関するバグ
  - ループしない場合でテストする
  - ループが1回の場合でテストする
  - 典型的なループ回数でテストする
  - 最大ループ回数より1少ない数でテストする
  - 最大ループ回数でテストする
  - 最大ループ回数＋１でテストする
- 要求仕様の間違い、機能が備わっていないバグ
- データに関するバグ
- マルチタスクや割り込みに関するバグ

### カバレッジテストの罠

- 非常にコストがかかるテスト
- カバレッジを上げれば上げるほどコストが等比級数的に増加

## 第3章　エンジニアが最もよく使う手法 ―ブラックボックステスト―

### ブラックボックステスト

- 4つの振る舞いさえテストすれば完璧
  - 入力処理
  - 出力処理
  - 計算
  - データ保存

### ブラックボックステストの基本

- 境界値分析法の適用
  - 入力処理
  - 出力処理
- 境界値分析法
  - ＞と>=の間違い
  - 数字やスペックの間違い
  - 境界がない
  - 余分な境界
- On-Offポイント法
  - 異なる処理が行われる一番近い2地点

### 複雑な入出力のためのテスト

- 例題
  - 入力A：1～999
  - 入力B：1～999
  - 出力C：AxB
- テストケース

|状態|ルール1|ルール2|ルール3|ルール4|
|---|---|---|---|---|
|A=正しい|true|true|false|false|
|B=正しい|true|false|true|false|
|計算値出力|true|false|false|false|
|入力エラー出力|false|true|true|true|

### GUIをテストする

- 有限状態マシン(FiniteStateMachine)
  - CLI：意味がない（常に入力待ち状態）
  - GUI：状態が遷移するので有効
- 見つかるバグ
  - 期待していない状態に遷移するバグ
  - 遷移自体がないバグ
- 適しているテスト
  - 複雑なGUI
  - オブジェクト指向ソフトウェア
  - 通信プロトコルテスト

### ブラックボックステストのまとめ

- 入力ダイアログボックスがあれば「境界値」テストを行う
- 複数の入力ダイアログボックスがあれば、「ディシジョンテーブルテスト」を行う
- ダイアログボックスの繊維があれば状態遷移テストを行う
- テストで見つけられる60%のバグを早く見つけ、その他のバグがなぜ発生したか、どうやって防止するかに時間を費やす

## 第4章　探索的テスト

- 結局バグなんてテストで全部見つからないんだから…
- 探索的テストとはソフトウェアの理解とテスト設計とテスト実行を同時に行うテストである

### 探索的テスト

- ソフトウェアテストの1つのスタイルである
- 個人に自由意志を持たせるとともに責任をより明確にする
- 一個人のテスト活動である
- 継続的にテスト活動を洗練させる
- 探索的テストは以下の活動を行う
  - テスト関連の学習
  - テスト設計
  - テスト実行
  - テスト結果を報告
- 成熟したテスト活動
- 上記を活動プロジェクト期間中平行して行う

### テストケースベースのテストとの比較

- 効率：探索的テスト＞テストケースベースのテスト
- 進め方
  - ソフトウェアを理解する
  - テストケースを書く
  - テストケースを実行する
- デメリット
  - 早い段階でテストケースを書くと仕様が不明確で精度が落ちる
  - 繰り返しが多いと考えなくなる

### 探索的テストのサンプル

- クライテリア決め

|定義|Pass基準|Fail基準|
|---|---|---|
|機能性|||
|安定性|||

- 探索的テストのタスク実行
  1. ターゲットソフトウェアを決める
  2. 機能をリストアップする
     - すべてのオンラインヘルプをチェック
     - すべてのメニューをチェック
     - サンプルデータの使用性をチェック
     - すべてのダイアログボックスのチェック
     - すべてのデータ、インターフェース、ウィンドウをダブルクリック
     - すべてのデータ、インターフェース、ウィンドウを右クリック
  3. 弱いエリアを見つける
     - データ交換が発生する機能（オブジェクトの埋め込み、ファイル変換）
     - ほかのソフトウェアとイベントを共有する機能（目覚まし機能、メール送信）
     - 使用頻度が少ない複雑な組み合わせのデータ入力をハンドルする機能
     - ファイルをネットワーク越しにオープンさせる機能
     - エラーや例外処理からの機能復帰
     - オペレーティングシステムとデータを交換させる機能（初期値）
     - オペレーティングシステムにサイズが依存する機能（メモリサイズの大きいファイル）
  4. 各機能のテスト及びバグの記録
  5. 継続的なテストの実行

- 非機能要求に対する探索的テストのアプローチ

|タイプ|探索的テスト|テストケーステスト|比較|
|---|---|---|---|
|ドキュメンテーション|8|4|200%|
|GUI|70|49|143%|
|矛盾点|5|3|167%|
|機能欠陥|98|96|102%|
|パフィーマンス|39|41|95%|
|技術的バグ|54|66|82%|
|ユーザビリティ|19|5|380%|
|間違った振る舞い|263|239|110%|

### 探索的テストのまとめ

- 探索的テストをしない理由はない
- 探索的テスト＋スキルあるテスト担当者＝短時間で高い結果を出す

## 第5章　要求仕様のテスト

- 要求のエラーは最も修正に費用がかかる

### 要求仕様

- プロジェクトを失敗しない要求仕様
  - 漠然たるユーザー要求を機能要求に落とし込む
  - 要求に優先順位をつける
  - テスト可能な要求を書く
  - 非機能要求
- 要求仕様
  - 完全である
  - 正当である
  - 実現可能である
  - 必要である
  - 優先順位がついている
  - 曖昧さがない
  - テスト可能である
    - ステート→条件もしくはアクション→特定された結果

### 要求の網羅（要求のテスト）

|要求|テストケース|テストケース|テストケース|
|---|---|---|---|
|要求1|○|NA|○|
|要求2|NA|○|NA|
|要求3|NA|○|○|

### ユーザーストーリーと要求

- アジャイル
  - 包括的なドキュメントよりも動くソフトウェアを
  - 顧客満足を最優先にし、価値あるソフトウェアを早く継続的に提供
- ユーザーストーリー
  - ストーリーは顧客と開発チームによって自然言語で書かれ、両者にとって理解可能である
  - ストーリーは短く簡潔で的を射ている。詳細な仕様ではなくむしろ会話の要約である
  - それぞれのストーリーはユーザーが何かしらの価値を与えられるものではなくてはならない
  - 独立している
  - 交渉可能
  - 価値がある
  - 見積りが可能
  - 小さい
  - テスト可能である

## 第6章　非機能要求のテスト ―困難さとの闘い―

- 非要求テストは、それぞれの非機能要求に対してテストのアプローチが異なる

### パフォーマンステスト

- 要求仕様通りのテストケースを書かない
  - 要求を逸脱するテストケースを書く
- パフォーマンステストは後回しにしない
  - パフォーマンステストで発見されるバグは最悪のバグ
- テスト5つのステップ
  1. アーキテクチャバリデーション
     - アーキテクチャ的に十分奈パフォーマンスか
       - DBの処理能力が足りているか？
  2. パフォーマンスベンチマーク
     - 実際のソフトウェアでテスト
  3. パフォーマンス回帰テスト
     - 更新されたソフトで性能低下がないことを確認する
  4. パフォーマンスチューニング、アクセプタンステスト
     - 最終製品のパフォーマンス確認
  5. 24x7パフォーマンスモニター
     - 24時間✕7日間を想定したダミーデータを使う

### セキュリティテスト

- 1日8時間労働のサラリーマン開発者がいくらセキュリティのしっかりしたコードを書いているといっても、1日24時間無給で楽しくハッキングしている人とでは勝負にならない
- セキュリティに特化した非機能要求
  - 機密性(Confidentiality)
  - 完全性(Integrity)
  - 可用性(Availability)
- セキュリティテストの難しさは、「悪意ある攻撃」に対しソフトウェア及びそのシステムが耐え得るかを確かめるテスト手法が存在しないところにある
  - モジュール指向のテスト
  - ファジングテスト
  - OWASP ZAP(Zad Attack Proxy)
  - 静的解析ツール
  - ペネトレーションテスト（侵入テスト）

### 信頼性テスト

- 信頼性
  - 成熟性(maturity)
  - 障害許容性(fault tolerance)
  - 回復性(recoverability)
- 信頼度成長曲線
  - m(t) = a(1-e^-bt)

## 第7章　テストの自動化という悪魔 ―なぜ自動化は失敗するのか―

### テスト自働化のメリット・デメリット

- 自働化のテストには多くの金額がかる
- テストが壊れ捨てられるものが多い
- 自働化に向くテスト
  - スモークテスト：たくさんの回数を繰り返す
  - パフォーマンステスト
  - APIのテスト
- 自動化に向かないテスト
  - 回帰テスト
  - グラフィックスやサウンドなどメディア関連のテスト

### 自働化テストの本当の問題点

- 自動化への期待だけが大きすぎる
- トレーニングコースの欠如、レベルの低さ
- 誤ったツール選択

### 自働化設計戦略

|レベル|記述レベル|概要|
|---|---|---|含めた
|Level1|線形スクリプト|手動で作成するか、手動のテストをキャプチャして記述する方法|
|Level2|構造化スクリプト|選択と繰り返しのプログラミング構造を使用する方法|
|Level3|共有スクリプト|スクリプトを他のスクリプトから呼び出すようにして再利用する方法|
|Level4|データ駆動スクリプト|コントロールスクリプトを使ってファイルにあるテストデータを読み込む方法|
|Level5|キーワード駆動スクリプト|ファイルにコントロールまで含めたテストについての情報をすべてを格納してしまう方法|

- キャプチャ／リプレイのツールで自働化せずに、データ駆動やキーワード駆動で自働化を行ってください

### 新たなソフトウェアテストのステージ（TDDなど）

- 単体テストを自働化
- UI周りは自働化を少なく

## 第8章　ソフトウェアテスト運用の基本 ―テスト成功の方程式―

### コストと品質のバランス

- 手ストにかかった費用 ＋ サポートにかかる費用 = 最小値
- 回収やサービス停止は最悪

### テストプランの書き方（IEEE 829テストプランテンプレート）

- テストプラン番号
- レファレンス（関連資料）
- はじめに（要約）
- テストアイテム
  - テストするソフトウェアバージョン
  - ソフトウェアのメディア、ハードウェアに依存するか
- テストするべき機能
- テストする必要のない機能
  - 意外と重要
- アプローチ
- テストアイテムの合否判定基準
- 中止基準と再開要件
- テスト成果物
- テスティングタスク
- 実行環境
- 責任範囲
- 人員計画、トレーニングプラン
  - 遅れの出ているソフトウェア開発プロジェクトに人員を追加するさらに遅れる
  - 最後に頭数をたくさん突っ込んで、バグをたくさん修正しても、いいことなんてまるでない
- スケジュール
  - プランなしでは、何事も進まない。しかしソフトウェアテストという作業は最もプランなしに進みがちなものである
  - スケジュールは正確に見積もることが最重要課題なのではなく、コントロールできるスケジュールが必要
  - テストスケジュールは開発スケジュールに依存する
  - 短くするための選択肢
    - 品質を下げる
    - 出荷を遅らせる
    - 機能を削る
  - ソフトウェアは小数精鋭でスケジュールに少し余裕を持って開発した方が良い
- リスクと対策
  - リスク = 問題の起こる確率 x 問題が起こった時のダメージ
    - 複雑度
    - 新規性
    - 変更
    - 依存性
- 承認
  - 終了基準：必ず測定可能な数字で表現すること

### テストケースの書き方

- いつ誰がやっても同じような結果が得られるように書かなければならない
- テストケース
  - ID
  - タイトル
  - 実行ステップ
    - 具体的な実行内容
  - 結果及び確認
  - 必要な環境及びソフトウェア

## 第9章　ソフトウェア品質管理の基本 ―ソフトウェア品質のメトリックス―

- テストという作業は、アウトプットが非常に見えにくいものです
- 計測できないものはコントロールできない

### 品質を目に見えるものにする

- 私情や恣意の入らないものを選ぶ
- 品質を十分代表するものを選ぶ

### バグの数を管理する

- バグメトリックス
  - バグの数
  - バグの数ｘ重要度
  - バグの修正時間
  - モジュールごとのバグ
    - 1個のコンポーネントの品質が引くければ、ソフト全体の品質も低い

### ソースコードメトリックス
  - コード行数とバグ密度
  - 複雑度のメトリックス

### Microsoftのメトリックス

- バグのメトリックス
  - 時間軸でのバグの発見数
  - コンポーネントごとのバグの発見数（大過ぎ、少な過ぎ）
- テストのメトリックス
  - コードカバレッジ
  - テスト担当者以外のバグ発見数
  - テストケースの数、テストの自働化率
- ソースコード
  - 追加、削除、変更されたコードの行数
  - KLOCs：どのくらいソースコードの行数が増加しているか？
  - コードの複雑度
- ソフトウェアの信頼性メトリックス
  - MTBF
  - 信頼性成長曲線
  - ストレステストを行った際のMTBF
- ビルドのメトリックス
  - ビルド時間
  - ビルドで見つかった問題
  - ビルドが失敗した原因
- スケジュールのメトリックス
  - 当初に立てたスケジュールと実際のずれ

### メトリックスの間違った使い方

- 人の能力や個人の仕事結果を測ってはいけない

### アジャイルメトリックス

- 顧客満足度
- MTTR
- FourKeyメトリックス
  - デプロイの密度
  - 変更のリードタイム
  - 変更障害率
  - サービス復元時間

## 第10章　新しいテスト技術

### AIをとりまくテスト

- AIテストはテストできないもののテスト

- テスト方法
  - メタモルフィックテスト
    - 画像を45度回転など、同じ答えが得られるかを確認
  - 経験ベースのテスト

### 複雑なシステムのテスト

- カオスエンジニアリング
- ランダムテスト（デタラメとは違う）