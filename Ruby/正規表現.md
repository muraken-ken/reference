# 正規表現(regular expression)
## 1. 正規表現とは？
文字列の集合を一つの文字列で表現する方法の一つである。（Wikipedia）

### 1-1. 正規表現の用途
- 大量のデータの中から特定のパターンに合致するデータを抽出
- 特定のパターンに合致する文字を置換

## 2. Rubyでの正規表現
### 2-1. Rubyの正規表現を確認
各言語ごとに微妙に仕様が異なる
- Ruby向け：[Rubular](https://rubular.com/)

参考になる記事
- [Ruby 3.0.0 リファレンスマニュアル  正規表現](https://docs.ruby-lang.org/ja/latest/doc/spec=2fregexp.html)
- [初心者歓迎！手と目で覚える正規表現入門・その１](https://qiita.com/jnchito/items/893c887fbf19e17d3ff9)
- [はじめての正規表現とベストプラクティス1](https://techracho.bpsinc.jp/hachi8833/2020_11_12/62948)


### 2-2. 正規表現オブジェクトの作り方
RubyではRegexpクラスで規定
1. //記法
```
/R..y/
```
2. Regexp.new(str)
```
re = Regexp.new("Ruby")
```
3. %r記法
```
%r(R..y)
%r<R..y>
%r|R..y|
%r!R..y!
```

### 2-3. メタ文字とエスケープ
- メタ文字：正規表現内で特殊な働きをする文字
```
( ) [ ] { } . ? + * | \
```
- エスケープ文字：メタ文字を文字としてマッチさせる「\」
```
/\\/ … \にマッチ
```

### 2-4. 式展開
式展開も利用可能
```
place = "東京都"
/#{place}/.match("Go to 東京都") # => #<MatchData "東京都">
```

### 2-5. 文字
「\」の後に文字列を置くことで、ある特定の文字を表現する<br>
これは、改行のように Ruby の文法で特別な意味を持つ文字を埋め込むためなどに用いられる
```
\t           水平タブ            horizontal tab (0x09)
\v           垂直タブ            vertical tab   (0x0B)
\n           改行                newline        (0x0A)
\r           復帰                return         (0x0D)
\b           バックスペース      back space     (0x08)
\f           改ページ            form feed      (0x0C)
\a           ベル                bell           (0x07)
\e           エスケープ文字      escape         (0x1B)
\nnn         符号化バイト値の8進数表現 (nnn の8進数3文字で表現)
\xHH         符号化バイト値の16進数表現 (HH の16進数2文字で表現)
\cx, \C-x    制御文字 (x は a から z までのいずれかの文字)
\M-x         メタ (x|0x80)
\M-\C-x      メタ制御文字
\uHHHH       ユニコード文字 (HHHH の16進数4桁)
\u{HHHHHH HHHHHH ....} ユニコード文字列 (HHHHHH は16進数1桁から6桁まで指定可能)
```
「\b」は文字クラス内でのみ有効な表現<br>文字クラスの外では単語の区切りを表すメタ文字列と解釈される

「\s」は文字列では空白(0x20)を意味するが、正規表現ではタブなどを含む空白文字全般にマッチするメタ文字列

### 2-6. 任意の1文字
メタ文字「.」は改行を除く任意の1文字にマッチ

### 2-7. 文字クラス
角括弧 [ と ] で囲まれ、1個以上の文字を列挙したもので、いずれかの1文字にマッチ
```
[abc]   => a, b, or c
[^abc]  => a, b, or c以外
[a-z[0-9]]  => [a-z0-9]
[a-w&&[^c-g]e]  => [a-w] && ([^c-g] || e) => [abeh-w] （差分）
&& は差分を表現できるので非常に有用
```
- 文字クラスの略記法
    - \w 単語構成文字 [a-zA-Z0-9_]
    - \W 非単語構成文字 [^a-zA-Z0-9_]
    - \s 空白文字 [ \t\r\n\f\v]
    - \S 非空白文字 [^ \t\r\n\f\v]
    - \d 10進数字 [0-9]
    - \D 非10進数字 [^0-9]
    - \h 16進数字 [0-9a-fA-F]
    - \H 非16進数字 [^0-9a-fA-F]

    これらの「空白」「数字」などは ASCII の範囲の文字のみを対象としている<br>「全角アルファベット」「全角空白」「全角数字」などはここの空白、数字、には含まれない

- ショートハンド: \b
「\b」：単語の境界にマッチする（スペース区切り言語が対象の場合）

- よく使われる文字範囲（保存版）
```
[0-9]       数字
[a-zA-Z]    英字（大文字小文字）
[a-zA-Z0-9] 英数字
[a-zA-Z0-9 !"#$%&'()*,.\/:;<>?@\[\\\]\^_`{|}~-] 英数字と半角スペースとASCII記号(-を最後に置いているのがポイント)
[ぁ-ん]     （まあ実用的な）全角ひらがな（除く特殊ひらがな）
[ァ-ヴー]   （まあ実用的な）全角カタカナ（除く特殊カタカナ、含ひらがなー）
[アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン][ァ-ヴー]+?    （もう少し実用的な）全角カタカナ語
[一-龠]                               （まあ実用的な）Unicode漢字
[〇一二三四五六七八九十百千万億兆京]  （まあ実用的な）Unicode漢数字
[\p{Katakana}][\p{Katakana}ー]+       全角カタカナ語
[\p{Katakana}ーｰﾞﾟ]                   全角＋半角カタカナ語
```

### 2-8. Unicodeプロパティによる文字クラス指定
Unicodeのプロパティ(属性情報)による文字クラス指定も可能
```
\p{property-name}
\p{^property-name} (否定)
\P{property-name} (否定)
```
- Unicodeプロパティ
  - \p{Hiragana}  ひらがな（長音除く）
  - \p{Katakana}  カタカナ（長音除く）
  - \p{Han}       漢字（長音除く）

## 3. ベストプラクティス
### 3-1. 「?」：直前の1文字が0個または1個であることを表すメタ文字
「?」：直前の1文字が0個または1個であることを表すメタ文字

直前の文字を修飾している
```
/コンピューター?/ => コンピュータ、コンピューター
```

### 3-2. 「+」：直前の1文字が「1個以上」繰り返されることを表すメタ文字
「+」：直前の1文字が「1個以上」繰り返されることを表すメタ文字
```
/ずうー+っと/ => 「ずうーっと」「ずうーーっと」「ずうーーーっと」
```
「+」の使用は注意が必要

### 3-3. 「{}」：繰り返し数の指定
「{}」：繰り返し数の指定
- {N}  ：直前の1文字をN回繰り返すことを表す
- {N,} ：直前の1文字をN回以上繰り返すことを表す
- {N,M}：直前の1文字をN回以上M回以下繰り返すことを表す
- {,N} ：直前の1文字をN回以下繰り返すことを表す（Rubyのみ）{0,N}、{1,N}でOK

[]、()にも修飾可能<br>
回数を数値で指定できる => 安心感高い => 積極的使用

### 3-4. 「\」：直後のメタ文字を通常の文字として扱う
「\」（バックスラッシュ）：直後のメタ文字を通常の文字として扱う（エスケープ）
```
/1\+1/ => 1+1 => 「+」を普通の文字で表す
/\\/ => \
```

### 3-5. 「.」：任意の1文字を表すメタ文字（ただし改行文字は除く）
「.」：任意の1文字を表すメタ文字（ただし改行文字は除く）<br>
「\n」や「\r」といった改行文字にはマッチしない点にご注意

「.+」：1文字以上の任意の長さの文字列<br>
注意:「+」量指定子は「最長一致」

「?」のもうひとつの機能: 最短一致<br>
「.+?」：1文字以上の任意の長さの文字列（最短一致）

注意:「.+」は使う前に考えよう => 意図しないマッチを呼び込む可能性がある<br>
「.+」を使うことは極力さける => 基本的に「.+」は凶暴

### 補足 「*」：直前の1文字の0回以上の繰り返しを表すメタ文字
「*」：直前の1文字の0回以上の繰り返しを表すメタ文字<br>
注意：「.*」をワイルドカードのように使用するのはNG => 不要なマッチを呼ぶ<br>

### 3-6. 「[]」：この記号で囲まれた文字のどれか1文字を表すメタ文字
「[]」：この記号で囲まれた文字（文字セット）のどれか1文字を表すメタ文字<br>
文字セット[]の中に書く文字の順序はマッチに関係ない<br>
```
id_[0123456789]+ => id_任意の数字
```

### 3-7. 「()」：文字列をグループ化するメタ文字
「()」：文字列をグループ化するメタ文字<br>
グループ化()の場合は文字の順序が保たれます<br>
()の直後に量指定子を置くことが可能<br>
()の中でメタ文字を使うことも可能<br>
「|」とよく併用される

### 3-8. 「|」：複数のパターンを列挙するメタ文字
「|」：複数のパターンを列挙するメタ文字 => OR演算（論理和）<br>
「|」は処理の優先順位が低い => 必要に応じて()で囲む<br>
無理して正規表現を一発で決める => 「|」で分割した方が可読性が良い<br>
```
/(引き|抜き)にくい/ => 「引きにくい」「抜きにくい」
/(引き|抜き)+にくい/ => 「引き抜きにくい」「引き引きにくい」
```
注意：「(||)+」は、上記のように注意が必要<br>
注意：「|」を余分につけてしまう事故

### 補足：|のワナ
```
/課長|課長補佐|課長補佐代理|課長補佐代理心得/ => 課長にすべてマッチ
```
- |で区切られた正規表現は、左から右に評価される
- 評価の結果一致すれば、そこで終了し、次の評価に進む

- 原因：注意すべきは部分文字列と順序と複数マッチ
  - |で区切られた文字列同士に、お互いの部分文字列（substring）が含まれている
  - 対象文字列に、部分文字列と長い文字列が両方含まれている
  - 対象文字列で複数のマッチ文字列を取るのが目的

- 対策1（アルファベット（スペース区切り）向け）: (\bと)\bで囲む
```
/\b(Get|GetValue|Set|SetValue)\b/ => \bは語の区切りを示す位置指定子
```

- 対策2（日本語向け）<br>
長い文字列から順に並べる
```
/課長補佐代理心得|課長補佐代理|課長補佐|課長/ 
```

### 3-9. 「\A」と「\z」：冒頭と末尾を表す
「\A」：文字列の冒頭を表す（\Aは大文字！）<br>
「\z」：文字列の末尾を表す（\zは小文字！）<br>

注意：「^」：行の冒頭を表す（原則避ける）<br>
注意：「$」：行の末尾を表す（原則避ける）<br>
=> Rubyでは「^」「$」をユーザー入力で使うと多くの場合、脆弱性の元になる場合がある<br>
```
/^すも.+?もも$/ => マッチした次の行にSQL文を挿入されるとSQLインジェクション
/\Aすも.+?もも\z/ => 上記の問題は回避できる

from Ruby スタイルガイド
string = "some injection\nusername"
string[/^username$/]   # マッチしてしまう
string[/\Ausername\z/] # マッチしない
```
特にWebアプリの入力値のような「信頼できない文字列」のバリデーションでは使わない

### 3-10. 「[^文字]」による文字セットの否定表現
「[^文字]」：指定された文字でない任意の1文字（否定）<br>
文字セット[ ]の冒頭に^を置くと、文字セットの否定を表現できる<br>
注意：[^文字]も文字セットなので、文字セット全体は1文字として扱われる<br>
注意：[^ABC]という文字セットは、「AでもBでもCでもない1文字」という意味<br>
注意：否定文字セットは、\nや\rや\tといった改行文字や非印刷文字にもマッチする <=> 「.」<br>
注意：正規表現はフレーズの否定（AAA or BBB以外など）は苦手

### 3-11. 「[ - ]」による文字範囲表現
「[a-z]」：aからzまでのいずれかの1文字を表す<br>
「[a-z0-9]」：aからzと0から9までのいずれかの1文字を表す<br>
-を文字セット[]内で使用する場合
- -を[ ]の中で最後に置く（苦し紛れ感）
- バックスラッシュ\でエスケープする

注意：スタイルとして範囲は文字セットの前半にまとめて置く

### 3-12. 「先読み」と「否定先読み」
「(?=正規表現)」：先読み（look-ahead）次の場合に使う
- その位置の直後に正規表現がある場合にのみマッチさせたい
- だが直後のその正規表現はマッチに含めたくない

「(?!正規表現)」：否定先読み（negative look-ahead）次の場合に使う
- その位置の直後に正規表現がある場合にのみマッチから除外したい
- だが直後のその正規表現はマッチに含めたくない

```
/(通過|通化)(?=スワップ)/ => スワップの前にある通貨、通化にマッチ
/(?=を祈)/ => ○○を祈るの「を」の前の位置にマッチ（文字ではなく位置）
/せっかく(?!なら)(?!だから)/ => せっかくなら、せっかくだからにマッチ
文字ではない => 並んで記載してもORと同じ
```

### 3-13. 「後読み」と「否定後読み」
「(?<=正規表現)」：後読み（look-behind）: 次の場合に使う
- その位置の直前に正規表現がある場合にのみマッチさせたい
- だが直前のその正規表現はマッチに含めたくない

「(?<!正規表現)」：否定後読み（negative look-behind）: 次の場合に使う
- 文字列の直前に正規表現がある場合にのみマッチから除外したい
- だが直前のその正規表現はマッチに含めたくない

```
 /(?<=再)コンパル/ => 再の後にあるコンパルにマッチ
(?<!テ)クノロジー(?!パーク) => テクノロジー、クロノジーパーク、テクノロジーパーク以外のクロノジーにマッチ
文字ではない => 並んで記載してもORと同じ
```

### 補足：先読みと後読み
先読みや後読みは、\Aや\zと異なり、原理的には正規表現の途中にいくつでも置ける（もちろん文字セット[]の中は除く）

```
/(?<=東京)(?<!大阪)特許(?=許可)(?!許諾)/
```
- 「特許」の直前は「東京」である
- 「特許」の直前は「大阪」ではない
- 「特許」の直後は「許可」である
- 「特許」の直後は「許諾」ではない

注意：肯定先読みの2つ以上の連続や、肯定後読みの2つ以上の連続は、たいてい無意味<br>
```
 /(?<=東京)(?<=大阪)/ => 永久にマッチしない
```

注意：肯定先読みと肯定後読みの連続は冗長（除くメタ文字）
```
/(?<=東京)(?=特許)/ => /(?<=東京特許)/とまとめるべき
```

注意：否定先読みと否定後読みの連続も無駄の多いパターン（除くメタ文字）
```
/(?<!東)(?!京)/ => /(?<!東京)/とまとめるべき
```

注意：先読み/後読みでも「否定」にはご用心
```
/(?<![青赤])巻紙/ => 巻紙でもマッチしてしまう
/(?<![青赤\n\r\t])巻紙/         => 改善案1
/(?<![青赤])(?<=[黄紫緑])巻紙/  => 改善案2
```

### 補足：「後読みで長さ不定の表現が使えない」問題の回避方法
1. 全体を|で分割して回避（否定でない後読みなら）
```
/(?<=(東京|大阪))特許事務所|(?<=(北海道|神奈川))特許事務所/
```
この|による全体分割は強力な味方<br>
それぞれの後読みの中で文字列の長さを揃えるのがコツ<br>

2. 複数の肯定後読みを()で囲んで|でつなぐ
```
 /((?<=(東京|大阪))|(?<=(北海道|神奈川)))特許事務所/
```
文字列の長さごとに肯定後読みを書き、それらを()で囲んで|でつなぐ方法

3. {N}で長さ指定して回避
```
/(?<=宮[一-龠]{2})特許事務所/
```
{N}量指定子による一意の長さ指定は例外的に使える

### 参考:DRYに書くのは意外に難しい
DRYな方法で期待外のマッチを排除しようとすると、正規表現の可読性がどんどん落ちる<br>
特に日本語を対象とする正規表現ではDRYな方向に頑張るとかえってこじらせてしまう可能性がある<br>
基本的にはDRYはほどほどにし、順序に注意して|で単純に列挙する方が無難

### 参考：ネガティブマッチもテストしよう
特に自然言語を対象に正規表現をかける場合、ネガティブな対象文字列（マッチして欲しくない文字列）についても事前に十分作ってテストすることが重要<br>
マッチして欲しい文字列だけでテストすると、多くの事故につながる

### 参考：対象の構造を意識して正規表現を書く
- DRYにしすぎない
- 構造を適度に保った
- 対象リストを元に正規表現を作るのもひとつの方法（降順ソート）

### 参考：余分なバックトラックを回避する
- バックトラックが余分に発生すると正規表現のパフォーマンスが落ちる
- 正規表現の途中に.+や.*を使う前に検討
- 対策1：.*?で最短一致にする
- 対策2：.をもっと絞り込む