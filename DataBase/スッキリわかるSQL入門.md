# スッキリわかるSQL入門

## 1. データベース概論
- データベース

  検索、書き換え、分析などを目的に様々な情報を蓄積したもの
- リレーショナルデータベース(RDB:Relational Database)

  一般的に広く利用されている複数の表の形式でデータを管理するデータベース
- RDBの基本構造
  - 複数の表(Table)で構成される
  - 個々のテーブルにはテーブル名がついている
  - テーブルは列(Column)と行(row)で構成される
  - 1行が1件のデータに対応し、列はその要素に対応する
  - SQLというデータベース操作言語で操作できる
- データベース管理システム(DBMS:Database Management System)

  データベースを管理するプログラム。SQLを受け取り処理を行う
- 代表的なRDBMS製品
  - 商用製品
    - Oracle Database (Oracle社)
    - DB2 (IBM社)
    - SQL Server (MicroSoft社)
  - OSS
    - MySQL (Oracle社)
    - PostgreSQL
    - SQLite
    - H2 Database
  - SQL文法

    ANSI、ISOで定められたSQL標準構文でほぼ動作するが、詳細は各DBのマニュアルを参照

## 2. SQLの基本文法
### 2-1. SQLの共通ルール
- 文の途中に改行を入れることができる
- 行の先頭や途中に半角の空白を入れることができる
- 末尾の「;」で文の終了を表す
- 「--」から行末まではコメントになり。無視される
- 「/\*～\*/」まではコメントになり、無視される
- SELECT、WHEREなどの命令に使う単語は予約語である
- 予約語を記述する際は、大文字／小文字の区別はない
- テーブル名、列名などに予約語は使用できない

### 2-2. リテラルの記述に関するルール
リテラル：SQL文中に書き込まれたデータそのもの
- 「'」でくくらず記述されたリテラルは数値情報として扱われる
- 「'」でくくられたリテラルは、基本的に文字情報として扱われる
- 「'」でくくられ'2013-03-25'のような一定の形式で記述されたリテラルは、日付情報として扱われる

### 2-3. データ型
データ型：列ごとに格納できるデータの種類<br>
利用可能なデータ型はRDBMSによる
- 代表的なデータ型
  - 数値
    - 整数：INTEGER型
    - 小数：DECIMAL型、REAL型
  - 文字列
    - 固定長：CHAR型
    - 可変長：VARCHAR型
  - 日付と時刻
    - DATETIME型、DATE型、TIME型

### 2-4. SQLの4大命令
- SELECT
```
SELECT 列名…  *：全項目
  FROM テーブル名 (AS 別名定義)
(WHERE 修飾)
(その他の就職)
```
- UPDATE
```
UPDATE テーブル名
  SET 列名1 = 値1, 列名2 = 値2,…
(WHERE 修飾)
```
- DELETE
```
DELETE
  FEOM テーブル名
(WHERE 修飾)
```
- INSERT
```
INSERT INTO テーブル名
            (列名1, 列名2, 列名3,…)
     VALUES (値1, 値2, 値3,…)
```

### 2-5. WHERE句による絞り込み
#### WHERE句の基本
- SELECT、UPDATE、DELETEで使用可能(INSERTは不可)
- 処理対象行の絞り込みに用いる
- WHEREの後ろには条件式を記述する
```
WHERE 条件式
```

#### 条件式
条件式：結果がTRUE(真)/FALSE(偽)になる式
- 主な比較演算子
```
WHERE 列名 >= 500
```
  - 「=」：等しい
  - 「<」：左辺が右辺より小さい
  - 「>」：左辺が右辺より大きい
  - 「<=」：左辺が右辺の値以下
  - 「>=」：左辺が右辺の値以上
  - 「<>」：左右の値が等しくない

- NULL判定<br>
NULL：何も格納されていない、未定義
```
WHERE 列名 IS NULL
```
  - 「IS NULL」：NULLであることを判定
  - 「IS NOT NULL」：NULLでないことを判定する

- LIKE演算子によるパターンマッチング
```
WHERE 列名 LIKE '%1月%'
```
  - パターン文字
    - 「%」：任意の0文字以上の文字列
    - 「_」：任意の1文字
  - ESCAPE句 指定した文字をエスケープ文字に指定できる
  ```
  WHERE 列名 LIKE '%100$%' ESCAPE '$'
  ```

- BETWEEN演算子による範囲判定（以上、以下）
```
WHERE 列名(式) BETWEEN 値1 AND 値2
```
ANDでも同様の処理が可能。BETWEENの方が処理が遅いこともある

- IN／NOT IN演算子
```
WHERE 列名(式) IN (値1, 値2, 値3,…)
```
一度に多くの値と比較が可能（「=」で比較）
  - 「IN」はOR条件で比較
  - 「NOT IN」は値以外を抽出

- ANY／ALL演算子
```
WHERE 列名(式) 比較演算子 ANY (値1, 値2, 値3,…)
WHERE 列名(式) 比較演算子 ALL (値1, 値2, 値3,…)
```
  - 「ANY」はOR条件で比較
  - 「ALL」はAND条件で比較

- 論理演算子
```
WHERE 条件式1 AND 条件式2
WHERE 条件式1 OR 条件式2
WHERE NOT 条件式
WHERE (条件式1 OR 条件式2) AND 条件式3
```
  - 「AND」は条件式1,2ともTRUE
  - 「OR」は条件式1,2のいずれかがTRUE
  - 「NOT」はTRUE／FALSEを反転
  - 処理は「NOT」>「AND」>「OR」の順番
  - ()で処理の優先順位を変えられる

#### 主キーとその必要性
完全に重複した行が存在すると区別、識別することはできない。重複しない列（主キー）が必要<br>
=> テーブル構造自体に問題あり
- 主キーとなる列が持つべき特性
  - NULLではない
  - 他の行と値が重複しない
- 主キーの種類
  - 自然キー：社員番号など
  - 人工キー、代替キー：出金番号など
  - 複合主キー：複数列でユニークなキーを作成

※ID列を作成するのが良い

## 3. 検索結果の加工
### 3-1. DISTINCT 重複行を除外する
```
SELECT DISTINCT 列名…
  FROM テーブル名
```

### 3-2. ORDER BY 結果を並べ替える
```
SELECT 列名… FROM テーブル名
  ORDER BY 列名 並び順(ASC/DESC 省略はASC), 列名 並び順…
```
- ASC(Ascending Order)：昇順
- DESC(Descending Order)：降順
- 「,」区切りで複数行を指定可能
- 列名の代わりに列番号（SELECTの記述順に1から数える）も指定可能

### 3-3. LIMIT 先頭から数行だけを取得する
```
SELECT 列名… FROM テーブル名
  (ORDER BY 列名 並び順)
  LIMIT 取得行数 (OFFSET 先頭から除外する行数)
```
- 基本的に「ORDER BY」と併用されることが多い<br>
（ORDER BYを使用しないと何が戻るか実行しないとわからない）

### 3-4 集合演算子 複数のテーブルを同時に処理する
- UNION：和集合
  ```
  SELECT 列名… FROM テーブル名1
    UNION (ALL)
  SELECT 列名… FROM テーブル名1
  ```
- EXCEPT(MINUS)：差集合
  ```
  SELECT 列名… FROM テーブル名1
    EXCEPT (ALL)
  SELECT 列名… FROM テーブル名1
  ```
- INTERSECT：積集合
  ```
  SELECT 列名… FROM テーブル名1
    INTERSECT (ALL)
  SELECT 列名… FROM テーブル名1
  ```
- 「ALL」：重複行をまとめずに出力する
- 集合演算子を使用するには、選択リストの列数、データ型の一致が必須<br>
（列が不足する時は「NULL」を追加して合わせることも可能）
- 「ORDER BY」を使用する場合、最後のSELECT文の後に記述する<br>
列名やASによる列名指定は最初のSELECT文の値を指定する

## 4. 式と関数
### 4-1. 計算式の使い方
#### 4-1-1. 選択列リストで計算式を使う
```
SELECT 列1,
       列1 + 100 AS 列名
       ’固定値’
  FROM テーブル名
```

#### 4-1-2. データの代わりに計算式を使う
```
INSERT INTO テーブル名 (列名)
  VALUES (1000 * 1.08)
```
```
UPDATE テーブル名 
  SET 列名1 = 列名1 + 100
```

### 4-2.  演算子の使い方
#### 4-2-1. 算術演算子
- 数値の四則演算：「+」「-」「*」「/」
- 日付の計算：「+」「-」
- 文字列の連結：「||」「+」

#### 4-2-2. CASE演算子
```
SELECT 列1, 列2
       CASE 列1 WHEN 値1(条件1) THEN 値1(条件1)のときに返す値
                WHEN 値2(条件2) THEN 値2(条件2)のときに返す値…
                ELSE デフォルト値
       END
  FROM テーブル名
WHERE …
```

### 4-3. 関数の使い方
- 関数はDBMSによって構文が異なるのでリファレンスを参照
- ユーザー定義関数：自分で記述し作成した関数
- ストアドプロシージャ：実行する複数のSQLをまとめ、プログラムとしてDBMSの外部から呼び出すもの

#### 4-3-1. 文字列にまつわる関数
- LENGTH／LEN 長さを得る
```
SELECT 列1, LENGTH(列1) AS 列1の長さ
  FROM テーブル名
WHERE LENGTH(列1) <= 10
```

- TRIM 空白を除去する（CHAR型の余白除去など）
```
SELECT 列1, LENGTH(列1) AS 空白除去そた列1
  FROM テーブル名
```

- REPLACE 指定文字を置換
```
UPDATE テーブル名
   SET 列1 = REPLACE(列1, 置換前の部分文字列, 置換後の部分文字列)
```

- SUBSTRING／SUBSTR 一部を抽出する
```
SELECT *
  FROM テーブル名
  WHERE SUBSTRING(列名1, 抽出開始位置, 抽出文字数) LIKE(%値%)
```

#### 4-3-2. 数値にまつわる関数
- ROUND 指定桁で四捨五入
```
SELECT 列名1, ROUND(列名1, 有効とする桁数) 正:小数の桁数、負：整数の桁数
  FROM テーブル名
```

- TRUNC 指定桁で切り捨てる
```
SELECT 列名1, TRUNC(列名1, 有効とする桁数) 正:小数の桁数、負：整数の桁数
  FROM テーブル名
```

- POWER べき乗を計算する
```
SELECT 列名1, POWER(列名1, 何乗するか指定)
  FROM テーブル名
```

#### 4-3-3. 日付にまつわる関数
- CURRENT_DATE 現在の日付を得る => YYYY-MM-DD
- CURRENT_TIME 現在の時刻を得る => HH:MM:SS
```
INSERT INTO テーブル名
  VALUES (値1, CURRENT_DATE)
```

#### 4-3-4. 変換にまつわる関数
- CAST データ型を変換する
```
SELECT CAST(列名1 AS VARCHAR(20)) + '円' … 数値を文字列変換し結合
  FROM テーブル名
```

- COALESCE 最初に登場するNULLでない値を返す<br>
NULLの場合の代替値を簡単に決められる
```
SELECT 列名1,
       COALESCE(列名2, 'NULLの代替値') AS 列名2
  FROM テーブル名
```

## 5. 集計とグループ化
### 5-1. 集計関数の使い方
- 検索対象の全行をひとまとめに扱い、1回だけ集計処理を行う
- 集計関数の結果は、必ず1行になる
- SELECT文の選択列リスト、HAVING句でのみ利用可能
- 結果の行数が揃っていること
- 引数に許される型が異なる
- 集計時、NULLは無視される

#### 5-1-1. 集計にまつわる関数
- SUM、MAX、MIN、AVG 合計、最大、最小、平均
```
SELECT SUM(列名1) AS 列名1の合計値,
       MAX(列名1) AS 列名1の最大値,
       MIN(列名1) AS 列名1の最小値,
       AVG(列名1) AS 列名1の平均値
  FROM テーブル名
SELECT AVG(COALESCE(列名1, 0)) AS NULLを0とした平均
  FROM テーブル名
```

- COUNT 行数を数える集計関数 
```
SELECT COUNT(*) …テーブル名の行数
  FROM テーブル名
SELECT COUNT(列名1) …NULLを除く列名1の行数
  FROM テーブル名
SELECT COUNT(DISTINCT(列名1)) …NULLと重複を除く列名1の行数
  FROM テーブル名
```

### 5-2. データをグループに分ける
#### 5-2-1. グループ分けにまつわる関数
- GROUP BY グループ化する
```
 SELECT グループ化の基準列, SUM(列名2) AS 合計
  FROM テーブル名
  (WHERE 絞り込み条件)
  GROUP BY グループ化の基準列
```

- HAVING グループ化してから絞り込む
```
 SELECT グループ化の基準列, SUM(列名2) AS 合計
  FROM テーブル名
  (WHERE 絞り込み条件)
  GROUP BY グループ化の基準列
  HAVING 集計結果に対する絞り込み条件
```

## 6. 副問い合わせ
### 6-1. 単一行副問い合わせ
- 検索結果が1行1列の1つの値となる副問い合わせ
```
SELECT 列名1, 
       (SELECT 列名2 FROM テーブル名2
          WHERE 値 = '値1') AS 列名2
  FROM テーブル名1
  WHERE  値 = '値1'
```
```
UPDATE テーブル名1
   SET 列名1 = (SELECT AVG(列名2)
                  FROM テーブル名2
                 WHERE 値 > 値1)
 WHERE 値 = '値2'
```

### 6-2. 複数行副問い合わせ
- 検索結果が複数の行からなる単一列（n行1列）の値となる副問い合わせ
- IN／NOT IN／ANY／ALL演算子と合わせて使用する
- 「<> ALL」 は、 「NOT IN」と同じ
- 「IN」は、「= ANY」と同じ
```
SELECT * FROM テーブル名1
 WHERE 列名1 IN (SELECT DISTINCT 列名2 FROM テーブル名2)
```
```
SELECT * FROM テーブル名1
 WHERE 列名1 < ANY (SELECT 列名2 FROM テーブル名2)
```
```
SELECT * FROM テーブル名1
 WHERE 列名1 < ALL (SELECT 列名2 FROM テーブル名2)
```

- 副問い合わせが「NULL」を含んでいた場合<br>
=> 「NOT IN」を使用すると全体の結果も「NULL」になる
```
SELECT * FROM テーブル名1
 WHERE 列名1 IN (SELECT 列名2 FROM テーブル名2
                  WHERE 列名2 IS NOT NULL)
```
```
SELECT * FROM テーブル名1
 WHERE 列名1 IN (SELECT COALESCE(列名2, '不明') FROM テーブル名2)
```
↑NULLにならない副問い合わせ

### 6-3. 表の結果となる副問い合わせ
- 検索結果が複数の行と複数の列（n行n列）の値となる副問い合わせ
```
SELECT SUM(SUB.列名1) AS 列名1の合計
  FROM (SELECT 列名1, 列名2, 列名3
          FROM テーブル名1
         UNION
        SELECT 列名1, 列名2, 列名3
          FROM テーブル名2
         WHERE 列名1 > 値1) AS SUB
```
```
INSERT INTO テーブル名2 (列名1, 合計, 平均)
     SELECT 列名1, SUM(列名2), AVG(列名2)
       FROM テーブル2
      WHERE 列名2 > 0
   GROUP BY 列名1
```

## 7. 複数テーブルの結合
### 7-1. RDBMSについて
#### 7-1-1. 複数テーブルに分けるメリット／デメリット
- メリット：データ整合性保持の容易性確保<br>
重複なく複数のテーブルに分けた方が、修正、更新等の操作でのミスなどを防げる<br>安全、確実、簡単にデータを管理できる
- デメリット：人には分かりづらい<br>
=> RDBは管理に適した複数テーブルから、人間が理解しやすい形態の1つの結果表を得るための結合(join)機能を備えている

#### 7-1-2. テーブルの結合
- テーブルAとテーブルBの結合
```
SELECT 選択列リスト
  FROM テーブルA
  JOIN テーブルB
    ON テーブルA.列名1 = テーブルB.ID
```

- 右表の結合条件の重複<br>
=> 左表の行を複製して結合する（元の左表の行数より増える）
- 結合相手のない／左表の結合条件がNULLの場合<br>
=> 結合結果から消滅する（元の左表の行数より減る）

#### 7-1-3. 左外部結合
- 左表の全行を必ず出力する<br>
結合相手のない／左表の結合条件がNULLの場合<br>
=> 選択列リストの値をNULLとして、必ず出力する（元の左表の行数は同じ）
```
SELECT 選択列リスト
  FROM テーブルA
LEFT JOIN テーブルB
    ON テーブルA.列名1 = テーブルB.ID
```

#### 7-1-4. 右外部結合
- 右表の全行を必ず出力する
```
SELECT 選択列リスト
  FROM テーブルA
RIGHT JOIN テーブルB
    ON テーブルA.列名1 = テーブルB.ID
```

#### 7-1-5. 完全外部結合
- 左右の表の全行を必ず出力する
```
SELECT 選択列リスト
  FROM テーブルA
FULL JOIN テーブルB
    ON テーブルA.列名1 = テーブルB.ID
```

#### 7-1-6. 内部結合と外部結合
- 内部結合：JOIN
- 外部結合：LEFT JOIN、ROGHT JOIN、FULL JOIN

#### 7-1-7. 結合に関するさまざまな構文
- テーブル名の指定
```
SELECT テーブルA.列名1, テーブルB.列名2
  FROM テーブルA
FULL JOIN テーブルB
    ON テーブルA.列名1 = テーブルB.ID
```
```
SELECT A.列名1, B.列名2
  FROM テーブルA AS A
FULL JOIN テーブルB AS B
    ON A.列名1 = B.ID
```

- 3テーブル以上の結合
```
SELECT テーブルA.列名1, テーブルB.列名2, テーブルC.列名3
  FROM テーブルA
  JOIN テーブルB
    ON テーブルA.列名1 = テーブルB.ID
  JOIN テーブルC
    ON テーブルB.列名2 = テーブルC.ID
```

- 副問い合わせの結果との結合
```
SELECT 列名1, B.列名2, B.列名3
  FROM テーブルA AS A
  JOIN (SELECT * FROM テーブルB
       WHERE 列名4 = 値) AS B
    ON A.列名2 = B.ID
```

- 同じテーブルを結合
```
SELECT A.列名1, B.列名2, B.列名3
  FROM テーブルA AS A
  JOIN テーブルA AS B
    ON A.列名2 = B.列名3
```

## 8. トランザクション
### 8-1. トランザクションとは
- 安全で確実なデータ操作とデータ管理が重要<br>
=> 以下の要因でデータが壊れる可能性もある
  - 予期しない処理中断
  - 同時操作<br>

- トランザクション制御(1)<br>
=> 1つ以上のSQL文をひとかたまりとして扱うように指示する
  - トランザクションの途中で処理が中断されないようにする
  - トランザクションの途中で他の処理が割り込めないようにする<br>
  トランザクションに含まれる複数のSQL文を以下の処理とする
    - 全ての実行が完了している
    - 1つも実行されていない

- コミットとロールバック
  - コミット<br>
  トランザクションが終了する際にデータ更新を確定する
  - ロールバック<br>
  トランザクションが正常に終了できなかった場合、前の状態に戻す

- トランザクションを使う指示
  - BEGIN：開始
  - COMMIT：変更を確定し終了
  - ROLLBACK：変更の取消をし終了
```
BEGIN;
INSERT INTO … ;
DELETE … ;
COMMIT;
```

- トランザクション制御(2)<br>
=> トランザクションを実行中、他のトランザクションを分離して実行する<br>
=> Lock

- 分離レベル
  - READ UNCOMMITTED
  - READ COMMITTED ←default
  - REPEATABLE READ
  - SERIALIZABLE

- 分離レベルの指定
'''
SET TRANSACTION ISOLATION LEVEL 分離レベル名
SET CURRENT ISOLATION 分離レベル名
'''

- 明示的なロッ
  - 行ロック
  ```
  SELECT ～ FOR UPDATE (NOWAIT)
  ```
  - 表ロック
  ```
  LOCK TABLE テーブル名 IN モード名 MODE (NOWAIT)
  ```
  - データベースロック

- ロックの種類
  - 排他ロック(exclusive lock)：他からのロックを許可しない
  - 共有ロック(shared lock)：他からのロックを許可する

- デッドロック<br>
=> 「X」をロックしたトランザクションAが次に「Y」をロックしよう<br>
=> 「Y」をロックしたトランザクションBが次に「X」をロックしよう<br>
=> 共にロックできなくて停止する<br>
=> 定期的に監視し、片方を強制的に失敗させることで解除する

- デッドロックの予防
  - トランザクションの時間を短くする
  - 同じ順番でロックするようにする

## 9. テーブル作成
### 9-1. SQL命令の分類
- データ操作言語(DML：Data Manipulation Language)<br>
=> データの格納、取出し、削除
```
SELECT、INSERT、UPDATE、DELETE
```

- データ定義言語(DDL：Data Definition Language)<br>
=> テーブルなどの作成や削除、各種設定

- データ制御言語(DCL：Data Control Language)<br>
=> DMLやDDLの利用に関する許可や禁止を設定
```
GRANT 権限名 TO ユーザー名  権限付与
REVOKE 権限名 TO ユーザー名 権限剥奪
```

### 9-2. データ定義言語(DDL)
- テーブル作成（基本形）
```
CREATR TABLE テーブル名 (
  列名1, 列1の型,
  列名2, 列2の型,

  列名n, 列nの型
)
```

- テーブル作成（デフォルト値指定）
```
CREATR TABLE テーブル名 (
  列名1, 列1の型 DEFAULT デフォルト値,
  列名2, 列2の型 DEFAULT デフォルト値,
  …
  列名n, 列nの型 DEFAULT デフォルト値
)
```

- テーブルの削除
```
DROP TABLE テーブル名
```

- テーブル定義の変更
```
ALTER TABLE テーブル名 ADD 列名 型 制約（列の追加）
ALTER TABLE テーブル名 DROP 列名 型 制約（列の削除）
```

- 全件のデータを削除する
```
TRUNCATE TABLE テーブル名 ←高速、ロールバック不可、必ず全行、DDL
DELETE FROM テーブル名 ←ロールバック化、時間がかかる、DML
```

- 制約 => 人為的なミスに備える
  - CREATE TABLE文中における制約の指定
  ```
  CREATR TABLE テーブル名 (
    列名1, 列1の型 制約の指定,
  )
  ```

- 制約の種類
  - NOT NULL制約 => NULLの格納は不可
  - UNIQUE制約 => 内容が重複してはならない（NULLは除く）
  - CHECK制約 => CHECKの後の条件式がTRUEとなる
  - 主キー制約 => 重複、NULLなく、主キーとしての役割を果たす
  ```
  CREATR TABLE テーブル名 (
    列名1, 列1の型 PRIMARY KEY,
  )
  ```
  ```
  CREATR TABLE テーブル名 (
    列名1, 列1の型,
    列名2, 列2の型,
    PRIMARY KEY(列名1, 列名2) …複合主キー
  )
  ```
  - 外部キー制約 => 参照性整合の崩壊を防ぐ
  ```
  CREATR TABLE テーブル名 (
    列名1, 列1の型 REFERRENCES 参照先テーブル名 (参照先列名),
  )
  ```
  ```
  CREATR TABLE テーブル名 (
    列名1, 列1の型,
    列名2, 列2の型,
    FOREIGN KEY(列名1) REFERRENCES 参照先テーブル名 (参照先列名)
  )
  ```
    - 参照整合性の崩壊要因
      - 「他の行から参照されている」行を削除してしまう
      - 「他の行から参照されている」行の主キーを変更してしまう
      - 「存在しない行を参照する」行を追加してしまう
      - 「存在しない行を参照する」行に更新してしまう

## 10. さまざまな支援機能
### 10-1. インデックス
- インデックスの作成
```
CREATE INDEX インデックス名 ON テーブル名 (列名)
```

- インデックスの削除
```
CREATE INDEX インデックス名
CREATE INDEX インデックス名 ON テーブル名
```

- インデックスの効果<br>
=> 作成した列の検索が高速化する
  - インデックスのある列をWHERE句で絞り込む
  - インデックスのある列をORDER BY句で並べ替える
  - インデックスのある列をJOINの結合条件に指定する（外部キーの列）

- インデックスのデメリット
  - 索引情報を保存するためにディスク容量を消費する
  - テーブルのデータが変更されるとインデックスも更新されるため、INSERT、UPDATE、DELETEのオーバーヘッドが増える

### 10-2. ビュー（View）
- ビューの作成と削除
```
CREATE VIEW ビュー名 AS SELECT文
DROP VIEW ビュー名
```

- ビューのメリット
  - SELECT文で抽出した結果を表として扱える
  - SQL文がシンプルになる
  - 参照権限を簡単に適切に設定できる
  - 結合して使うことの多いテーブルは、結合済みの表をビュー定義しておくと便利

- ビューの制約とデメリット
  - ビューは「名前をつけたSELECT文」でしかない
  - 実行するSQLが簡単でも、SELECT文が複雑だと高負荷になる可能性がある

- マテリアライズドビュー
  - SELECT文による検索結果をディスクに保存しておく
  - 高速
  - ディスク容量が増える

### 10-3. 連番管理
- 採番テーブル<br>
=> 専用の採番テーブルで番号を管理する
- 連番が自動的に振られる列の定義<br>
=> 各DBMSで異なるので、リファレンスを参照
- 連番を管理してくれるツール<br>
=> シーケンス
```
CREATE SEQUENCE シーケンス名
DROP SEQUENCE シーケンス名
```
- 最大値を用いた採番 => 推奨しない
  - 複数の人に同じ番号を採番されてしまう
  - ロックを利用すると対策できるが、パフォーマンス低下
  - 行削除後に採番すると同じ番号の再利用をしてしまう

### 10-4. ACID特性
- DBが備える安全機構
  - 原子性(Atomicity)   ：コミット、ロールバック
  - 一貫性(Consistency) ：型、制約
  - 分離性(Isolation)   ：トランザクションの分離レベル、ロック
  - 永続性(Durability)  ：バックアップ

- バックアップの整合性
  - オフラインバックアップ：DBMSを停止して行うバックアップ
  - オンラインバックアップ：DBMSを稼働させながら行うバックアップ（制約あり）

- 2つのファイルのバックアップ
  - データベースの内容：低頻度（日次、週次、月次）
  - ログファイルの内容：高頻度（数分～数時間ごと）
    - REDOログ／トランザクションログ<br>
    => 実行したSQL文を保存

- 復元方法
  - データベース内容＋ログファイルのロールフォワード

## 11. データベースの設計
### 11-1. データベースの設計手順
1. 要件の調査（顧客ヒアリング）：INPUT
2. 概念設計
3. 論理設計
4. 物理設計
5. DDL：OUTPUT

### 11-2. 概念設計
- ER図(ERD：Entity-Relation Diagram)を作成する
  - エンティティ：テーブルのようなもの
  - 属性：テーブルの列のようなもの
  - 関係：リレーションのようなもの
  - 多重度（カーディナリー）：1対1、多、多(0以上)、多(1以上)

- ER図の種類
  - IE(Infomation Engineering)
  - IDEF1X

- エンティティの導き方
  1. 候補となる用語を洗い出す
  2. 不要な用語を捨てる
  3. 関連がありそうなものをまとめる
  4. エンティティ名と属性名に分ける

### 11-3. 論理設計
リレーショナルデータモデルで扱いやすい形のテーブルに変形する
- 論理設計の手順
  1. 多対多の分解 => 1対多（中間テーブル）に変換
  2. キーの整理
  3. 正規化

- 主キーが備えるべき特性
  1. 非NULL性 ：必ず値を持っている
  2. 一貫性   ：他と重複しない
  3. 不変性   ：値が変化することがない

- 正規化
=> 矛盾したデータを格納しないようにテーブルを複数に分割する
  - 設計の原則：「1つの事実は1箇所に」(One-fact in one-Place)

- 正規化の手順
  1. 非正規化→第1正規形への変形<br>
  => テーブルの全ての行、列に値が入っているべき、繰り返し、結合がない
      - 繰り返しの列 → 別の表に切り出す
      - 切り出した表の仮の主キーを決める
      - 主キーの列をコピーして複合主キーを構成する

  2. 第2正規形への変形（複合主キーのテーブルのみ）<br>
  => 全ての非キー列が複合主キーの全体に関数従属すること<br>
  =>（部分関数従属の排除）
      - 関数従属性<br>
      => 「ある列Aの値が決まれば列Bの値も決まる」という関係を「列Bは列Aに関数従属している」
      - 複合主キーの一部に関数従属する列を切り出す
      - 部分関数従属先だった列をコピーする

  3. 第3正規形への変形<br>
  => 全ての非キー列が主キーに直接、関数従属すること<br>
  => （推移関数従属の排除）
      - 間接的に主キーに関数従属する列を切り出す
      - 直接関数従属先だった列をコピーする
  
  4. この時点のテーブル構造をER図にまとめておく

### 11-4. 物理設計
使用するDBMSを確定し、全テーブルの詳細な設計（DDL）を行う
- 物理設計の手順
  1. 最終的なテーブル名、列名（物理名）を決定する
      - 物理名：実際のDBの名前
      - 論理名：論理設計までの名前
  
  2. 列の型を決定する
  3. 制約、デフォルト値を決定する
  4. インデックスを決定する
  5. その他：ビューの作成、性能のための正規化など

### 11-5. データの利用
- 管理：データは複数のテーブルに分割してある方が良い <= 正規化
- 利用：データは1つのテーブルに結合してある方が良い <= 結合
