# プログラマー脳 ～優れたプログラマーになるための認知科学に基づくアプローチ

## Part 1 コードをよりよく読むために

### Chapter 1 コーディング中の混乱を紐解く

#### 1.1 コードにおけるさまざまな種類の混乱

- 1.1.1 混乱のタイプその1：知識不足
  - 言語、アルゴリズム、ビジネス領域
- 1.1.2 混乱のタイプその2：情報不足
  - コードを理解するすべての情報にアクセスできない
- 1.1.3 混乱のタイプその3：処理能力の不足
  - コードが脳の処理能力を超えるほど複雑

#### 1.2 コーディングに影響を与えるさまざまな認知プロセス

- 混乱の種類と認知プロセス
  - 知識不足＝長期記憶の問題
  - 情報不足＝短期記憶の問題
  - 処理能力の不足＝ワーキングメモリ
- 1.2.1 長期記憶とプログラミング
  - 長期記憶がない＝知らなければ理解はできない
- 1.2.2 短期記憶とプログラミング
  - 短期記憶は数個しか覚えられない。すぐに忘れる。
- 1.2.3 ワーキングメモリとプログラミング
  - 実際の思考を行う。コードのトレースなど

#### 1.3 それぞれの認知プロセスが協調的に動作する仕組み

- 1.3.1 認知プロセスの相互作用の概要
  - 思考をする＝3つの認知プロセスすべてが状況に応じて活性化される
  - 情報 => フィルタ => 短期記憶 => ワーキングメモリ <= 長期記憶
- 1.3.2 プログラミング作業に関係する認知プロセス

### Chapter 2 コードを速読する

#### 2.1 コードの速読法

- 2.1.1 今、あなたの脳内で何が起きたのでしょうか？
  - オリジナルコード => 短期記憶 ＋ 長期記憶 => 再現コード
- 2.1.2 再現したコードを見直しましょう
  - 長期記憶は人の経験値によって異なる
- 2.1.3 2回目のコード再現の振り返り
  - 短期記憶の容量には限りがある
    - マジカルナンバー：7±2つ
    - 最新の研究：2～6つ
- 2.1.4 なぜ馴染みのないコードを読むのは難しいのか？

#### 2.2 記憶のサイズ制限を克服する

- 2.2.1 チャンキングの威力
  - 長期記憶に保存された情報を多用する
- 2.2.2 熟練プログラマーは初心者よりもコードをよりも上手に記憶できる
  - 熟練プログラマーは長期記憶に保存された情報量が多い

#### 2.3 読めるコードよりも見えるコードのほうが多い

- 2.3.1 アイコニックメモリ（間隔記憶）
  - 見たコード => アイコニックメモリで選択され短期記憶へ
  - コードをざっと読むことでコードのイメージを掴み理解を助ける
- 2.3.2 何を覚えているのかではなく、どのように覚えたか
  - 内容だけでなく順序も大事
  - チャンク化しやすいコードを書く
  - デザインパターンを利用する
  - コメントを書く
  - ビーコンを残す（ビーコン：プログラマーがコードの内容を理解するのに役立つプログラムの部分）
    - 単純なビーコン
    - 複合的なビーコン
- 2.3.3 チャンク化の練習

### Chapter 3 プログラミング言語の文法を素早く習得する方法

- プログラミング言語の文法はインターネットで調べられるが、知っていると知らないではコードを効率的に処理できるかの違いが出る

#### 3.1 文法を覚えるためのテクニック

- プログラミングに関する概念、データ構造、文法を知っているほど、多くのコードを簡単にチャンク化でき、その結果、より多くの情報を記憶し処理することができる
- 3.1.1 割り込みがワークフローを混乱させる
  - 割り込みは効率を大きく下げる。短期記憶の内容を忘れさせる。

#### 3.2 フラッシュカードを使って文法を素早く覚える

- 3.2.1 フラッシュカードを利用するタイミング
  - フラッシュカードを使って繰り返し練習する
- 3.2.2 フラッシュカードのセットを拡張する
  - あたらしいプログラミング言語やフレームワーク、ライブラリを学び始めたとき
- 3.2.3 フラッシュカードのセットについて考える
  - 覚えたカードは外す

#### 3.3 物忘れを防ぐには

- 3.3.1 なぜ我々の記憶は失われてしまうのか？
  - 脳は階層構造ではなく、ネットワーク構造で記憶している
  - 忘却曲線
- 3.3.2 間隔をあけて繰り返す
  - 長い間隔を空けて繰り返す方がより記憶に定着する
  - 繰り返さないと記憶に定着しない

#### 3.4 文法を長く記憶に留めるには

- 3.4.1 情報を記憶する2つの形態
  - 貯蔵強度
  - 検索強度（積極的に思い出す行為が大事）
- 3.4.2 情報をただ見るだけでは不十分
- 3.4.3 情報を覚えることで記憶が強化される
  - 積極的に覚えようとすることで記憶が強化される
  - 毎回調べると脳が覚えなくても良いと思ってしまう
- 3.4.4 能動的に考えることで、記憶を強化する
  - 積極的に情報を考え、振り返ること
  - 精緻化：学んだばかりの情報について考えるプロセス
  - スキーマ：脳内記憶のネットワークで思考とその関係が整理されたもの
    - 覚えたいことを考え、それを既存の記憶と関連付け、新しい記憶をすでに保存されているスキーマに適合させる

### Chapter 4 複雑なコードの読み方

#### 4.1 複雑なコードを理解するのが難しい理由

- 4.1.1 ワーキングメモリと短期記憶の違いは何か
  - 定義：ワーキングメモリ＝「問題の処理に用いられる短期記憶」
  - ワーキングメモリも短期記憶同様に容量制限がある
    - 2～6個を超える：認知的負荷
- 4.1.2 プログラミングに関連する認知的負荷の種類
  - 課題内在的負荷：その課題自体がどれくらい複雑か
    - 問題そのものに関する知識
  - 課題外在的負荷：その問題の妨げとなる外部要因
    - 変数など、認識するために関連付けて覚えるもの
  - 学習関連負荷：考えたことを長期記憶に保持する際に引き起こされる認知的負荷

#### 4.2 認知的負荷を軽減するテクニック

- 4.2.1 リファクタリング
  - 保守性の高いコード＝認知的負荷が低いとは限らない
  - 自分が読みやすいリファクタリング：認知的リファクタリング
    - 人により形が異なる
- 4.2.2 使い慣れない言語構造の置き換え
- 4.2.3 同義で書き方の違うコードはフラッシュカードデッキの非常によい追加要素

#### 4.3 ワーキングメモリに負荷がかかっているときに使える記憶補助ツール

- 4.3.1 依存関係グラフを作成する
  1. すべての変数を丸で囲む
  2. 同じ、あるいは関連した変数を線でつなぐ
  3. すべてのメソッド／関数の呼び出しを丸で囲む
  4. メソッド／関数呼び出しをその定義場所と線でつなぐ
  5. クラスのインスタンスをすべて丸で囲む
  6. クラス定義とそのインスタンスの間に線を引く
- 4.3.2 状態遷移表の利用
  1. すべての変数の一覧を作る
  2. 表を作り、すべての変数の列を作成する
  3. コードの実行と区切りとなる部分ごとに表に行を追加する
  4. コードを頭の中で実行し、各変数が持つ値を状態遷移表のそれぞれの行に書き込む

  ||N|N2|B$|N1|
  |---|---|---|---|---|
  |Init|7|7|-|7|
  |Loop1||3|1|3|
  |Loop2|||||

- 4.3.3 依存関係グラフと状態遷移表を組み合わせる

#### 本章のまとめ

Part 2 コードについて考える

### Chapter 5 コードの深い理解に到達する

#### 5.1 「変数の役割」フレームワーク

- 5.1.1 違う変数は違う目的を持つ
  - 広すぎるチャンク：一般的な名前
  - 狭すぎるチャンク：狭義すぎる名前
  - どちらも認知的負荷を軽減できない
- 5.1.2 ほぼすべての変数をカバーできる11の役割
  - 固定値：定数や変更されない変数
  - ステッパー：ループの度に値が変更される（処理）
  - フラグ：真偽値が普通
  - ウォーカー：forループのiなど
  - 直近の値の保持者
  - 最も重要な値の保持者
  - 収集者：ループ処理のまとめ戻り値など
  - コンテナ：リスト、配列、スタック、ツリーなど
  - フォロワー：前の値や後の値
  - オーガナイザー：値の並べ替えなど
  - テンポラリ：短期間のみ使われる

#### 5.2 役割とパラダイム

- 5.2.1 役割を見付けることの利点
  - 変数の役割を書くと理解しやすくなる
- 5.2.2 ハンガリアン記法
  - ハンガリアン記法：型を持たない言語で名前から型を見分けられるようにした命名規則

#### 5.3 プログラムに関する知識を深める

- 5.3.1 文章の理解と計画の理解
  - テキスト構造の理解
  - 計画の理解
- 5.3.2 プログラムの理解に関するさまざまな段階
  1. フォーカルポイント（コードで注目すべき場所）を見つける
  2. そのフォーカルポイントから知識を拡張していく
  3. 関連している要素から、そのコードに利用されている懸念を理解する
  4. 複数の要素を横断して利用されている懸念を理解する

- コードへの深い理解のための段階の適用
  - ワーキングメモリの記憶補助
  - プログラムの理解に関するさまざまな段階

#### 5.4 文章を読むこととコードを読むことは似ている

- 5.4.1 コードを読む際に脳内では何が起こっているのか
  - ブロードマン領野：脳を52種類領域に分類
  - 自然言語処理と同じ領域を使っている
- 5.4.2 もしフランス語を学べるなら、Pythonも学ぶことができる
  - 実験でも自然言語の学習応力の高さとリンク

#### 5.5 コードを読む際にも適用可能な文書理解の戦略

- 5.5.1 過去の知識の活性化
  - 関連する事柄を積極的に考え、過去の知識を活性化させる
- 5.5.2 監視
  - 文章の理解度を把握し続ける
- 5.5.3 コード中のどの行が重要なのかを判断する
  - 文章のどの部分が最も関連性が高いかを判断する
- 5.5.4 変数の名前の意味を推論する
  - 文章にはっきりと書かれていない事実を補完する
- 5.5.5 可視化
  - 読んだ文章の内容を図解して理解を深める
- 5.5.6 自問自答
  - その文章について質問を作り、それに答える
- 5.5.7 コードの要約
  - 文章の短い要約を作成する

### Chapter 6 プログラミングに関する問題をよりうまく解決するには

#### 6.1 コードについて考えるためにモデルを利用する

- 6.1.1 モデルを利用することの利点
  - モデル：現実を単純化した表現
  - 理解を容易にすることを助ける

#### 6.2 メンタルモデル

- 6.2.1 メンタルモデルを詳しく検討する
  - メンタルモデル：頭の中で利用し、実際に手を動かして何らかの作業をすることを必要としない
  
  |特性|具体例|
  |---|---|
  |不完全|変数を箱と考えるモデルは、再代入を正確に表せない|
  |不安定|初学者には箱でも、後には名札の方がよい|
  |矛盾した状態で共存|箱と名札が同時存在できる|
  |変な例え|PCにちゃんと動いてとお願いする|
  |人は無駄を惜しむ|問題を表現したメンタルモデル作成よりも力技|

- 6.2.2 新しいメンタルモデルを学ぶ
- 6.2.3 コードについて考えている際にメンタルモデルを効果的に使う方法
  - 具体的なモデルはより効果的に活用できる
  - ワーキングメモリにおいてソースコードのメンタルモデルの形成を行う
    1. 局所的なモデルの構築から開始する
    2. コード内の関連するすべてのオブジェクトと、オブジェクト間の関係を表に書き出す
    3. そのシステムに関する自問自答を行い、その解答を使ってモデルを改良する
       - システムの最も重要な要素はどれでしょうか？そしてこれらはモデル内に存在していますか？
       - ここで挙げた重要な要素の間には、どのような関係がありますか？
       - このポリグラムの主たる目的は何でしょうか？
       - その目的は、中心となっている要素や要素間の関係にどのように関係していますか？
       - このコードの典型的なユースケースは何でしょうか？それはモデルでカバーされていますか？
  - 長期記憶においてソースコードのメンタルモデルの形成を行う
    - データ構造：有向グラフや無向グラフ、さまざまなリスト構造など
    - デザインパターン：Obseverパターンなど
    - アーキテクチャパターン：MVCなど
    - ダイアグラム：実態関連ダイアグラムやシーケンス図など
    - モデリングツール：状態図やペトリネットなど

#### 6.3 想定マシン

- 6.3.1 想定マシンとは何か
  - 想定マシン：コンピュータがコードを実行する方法について考える時に使うモデル
- 6.3.2 想定マシンの実例

  ```ruby
  a = 10
  b = 5
  c = a + b  # c = 10 + 5 に置き換えて理解
  ```

- 6.3.3 さまざまなレベルの想定マシン

#### 6.4 想定マシンと言葉

- 6.4.1 想定マシンの拡張
- 6.4.2 想定マシン同士がメンタルモデルを作り出す場合

#### 6.5 想定マシンとスキーマ

- 6.5.1 なぜスキーマが重要なのか
  - スキーマ：長期記憶が情報を保持するための方法
  - 変数は箱のようにスキーマと結びつけると理解が容易になる
- 6.5.2 想定マシンは意味論的なものか

### Chapter 7 誤認識：思考に潜むバグ

#### 7.1 2つ目のプログラミング言語を学ぶのは、最初の言語を学ぶよりも、なぜ簡単なのか

- 転移：何かを学習したとき、その知識が別の領域でも役に立つことがある
  - 学習中の転移
  - 学習の転移
- 7.1.1 既知のプログラミングに関する知識を最大限活用する方法
  - 習熟度
  - 類似度
  - コンテクスト
  - 重要な性質に関する知識
  - 関連性
  - 感情
- 7.1.2 転移の種類
  - 一般道の転移：意識せずともできる
  - 高速道の転移：意識してやる複雑なタスク
  - 近転移：類似したもの
  - 遠転移：類似していないもの
- 7.1.3 すでに持っている知識は呪いか幸いか
  - 正の転移：良い影響をあたえる
  - 負の転移：悪い影響をあたえる
- 7.1.4 転移の難しさ
  - 転移には正も負もある

#### 7.2 誤認識：思考の中のバグ

- 誤認識
  - 不完全で間違っている
  - 異なる状況下でも一貫して保持される
  - 確信が持たれている
- 7.2.1 概念変化で誤認識をデバッグする
  - 概念変化：新しく学ぶ言語に適したメンタルモデルに置き換える
- 7.2.2 誤認識の抑制
- 7.2.3 プログラミング言語に関する誤認識
  - 論文では、162種類の誤認識が紹介されている
- 7.2.4 新しいプログラミング言語を学習する際の誤認識を防ぐ
  - オープンマインド
  - 誤認識を意識して学習する
  - 経験者の意見を聞く
- 7.2.5 新しいコードを読む際の誤認識を診断する

## Part 3 よりよいコードを書くために

### Chapter 8 よりよい命名を行う方法

#### 8.1 なぜ名前が重要なのか

- 8.1.1 なぜ名前が重要なのか
  - 名前はコードの大部分を占める
  - コードレビューにおける名前の役割
  - 名前は最もアクセスしやすいドキュメントである
  - 名前はビーコンとしても機能する
- 8.1.2 命名に対するさまざまな考え方

  - 良い名前は文法で定義できる
  
  |名前|説明|例|
  |---|---|---|
  |ルールを逸した大文字の使用|大文字は適切に使用|pagecounter|
  |アンダースコアの連続|アンダースコアは連続して使うべきではない|page__counter|
  |辞書に載っている単語の利用|意味のわかる単語のみ利用|pag_counter|
  |単語数|2～4単語で構成||
  |多すぎる単語|5単語以上使うべきではない||
  |短すぎる識別子|8文字未満であってはならない||
  |列挙型識別子の宣言の順番|基本アルファベット順||
  |前後のアンダースコア|先頭や末尾にアンダースコアはつけない||
  |型情報の追加|ハンガリアン記法などで型情報をつけない||
  |長すぎる識別子|可能なら長い識別子は避ける||
  |ルールを逸した命名|一般的ではない方法での大文字小文字の組み合わせ|Page_counter|
  |数字を表す識別子|数字を表す単語だけで構成しない|FIFTY|

  - 名前はコード内で一貫していなければならない

- 8.1.3 初期の命名の慣習は永続的な影響を与える
  - 命名の経年変化に関する知見
    - 新しい時代に書かれたコードは、命名のガイドラインに沿ったものになっている
    - 同じコードベースでは、命名の習慣は変化しづらい
    - 命名規則は、コードベースの大きさによって違いは出ない

#### 8.2 命名の認知科学的側面

- 8.2.1 短期記憶の働きを助ける名前の形式
- 8.2.2 長期記憶の働きを助ける明快な命名
- 8.2.3 変数名には理解を助けるためのさまざまな情報が含まれている
  1. 名前はコードが対象とするビジネス領域に関する情報を与えてくれる
  2. 名前はプログラミングそのものに関する情報も与えてくれる
  3. 変数名そのものが、長期記憶に保持された情報と関連付けられている場合もある
- 8.2.4 名前の品質は、いつ評価すべきか
  - コードレビューが良い機会

#### 8.3 どんな名前が理解しやすいのか

- 8.3.1 略すべきか、略さざるべきか？
- 8.3.2 スネークケースか、キャメルケースか？

#### 8.4 名前がバグに与える影響

- 8.4.1 よくない名前が使われているコードはバグを生みやすい

#### 8.5 よりよい名前を選ぶには

- 8.5.1 名前の雛形
- 8.5.2 フェイテルソンによる、よりよい変数名のための3ステップのモデル
  1. 名前に含めるべき概念を選択する
  2. それらの各概念を表す単語を選ぶ
  3. それらの単語を使って命名を行う

### Chapter 9 汚いコードとそれによる認知的負荷を避けるための2つのフレームワーク

#### 9.1 臭いのあるコードは、なぜ認知的負荷が大きいのか

- 9.1.1 コードの臭いの簡単な説明
  - コードの臭い：コードスメル：理想的な構成になっていないコードの部分
  
  |コードの臭い|説明|レベル|
  |---|---|---|
  |長すぎるメソッド|原則1つのメソッドに1種類の処理。|メソッド|
  |多すぎる引数|メソッドは多すぎる引数を受け取ってはならない。|メソッド|
  |switch文|巨大なswitch文は作らない。ポリモーフィズムを利用すべき。|メソッド|
  |クラスのインタフェースの不一致|ぱっと見では違うけど、フィールドやメソッドが類似している複数のクラスは作らない。|クラス|
  |基本データ型への執着|一つのクラス内で基本データ型を使いすぎないようにする。|クラス|
  |未熟なクラスライブラリ|メソッドは適当なクラスに追加するのではなく、ライブラリクラスに追加する。|クラス|
  |巨大なクラス|メソッドやフィールドが多すぎるクラスは作らない。|クラス|
  |怠け者クラス|小さな仕事しかしないクラスは作らない。|クラス|
  |データクラス|データだけを保持するクラスを作るべきではなく、メソッドも追加すべき。|クラス|
  |一時的属性|クラスに不必要な一時的なフィールドを用意すべきではない。|クラス|
  |データの群れ|複数のデータがいつも同じ組み合わせになって使われているなら、クラスか構造体まとめる。|クラス|
  |変更の偏り|何か一つの変更を加える際に，多くの異なるクラスに小さな変更を加えなければならない状態。|コード一般|
  |特性の横恋慕|クラスAのメソッドがクラスBから何度も参照されているなら、そのメソッドはクラスBに移動するとよいかも。|コード一般|
  |不適切な関係|クラス同士の密な構造はだめ。|コード一般|
  |重複したコード|同じようなコードは複数個所に書かないような構造が望ましい。|コード一般|
  |コメント|コメントはそのコードが何をするかではなく、なぜそのコードが必要なのかを説明する必要がある。|コード一般|
  |メッセージの連鎖|メソッドがメソッドを呼び、さらにメソッドを呼びといったようなメソッドの長すぎる連鎖は避けるべき。|コード一般|
  |仲介人|責務をほかのクラスにたくさん委譲してるクラスは必要ないかもしれない。|コード一般|
  |パラレル継承|あるクラスのサブクラスをつくるとき、別のクラスのサブクラスも作る必要があったとしたら、両方のクラスの機能を一つにまとめられる。類似した継承構造を持つクラス群が複数存在する状態。|コード一般|
  |相続拒否|クラスが自身では使用しない挙動を継承している場合、その継承はいらないものかも。|コード一般|
  |変更の分散|クラスに変更を加える際に，関係のない多数のメソッドに変更を加えなければいけない状態。|コード一般|
  |疑わしき一般化|「一応念のため」のコードは作らないようにする。|コード一般|

- 9.1.2 コードの臭いは認知にどんな悪影響を及ぼすか
  - 長すぎるパラメータリスト、複雑なswitch文：ワーキングメモリーの容量オーバー
  - 神クラス、長すぎるメソッド：効率的なチャンク化ができない
  - コードクローン：間違ったチャンク化を引き起こす

#### 9.2 悪い名前が認知的負荷に与える影響

- 9.2.1 言語的アンチパターン
  - メソッド名に書かれた以上の働きをするメソッド
  - 実際の働き以上のことをするかのごときメソッド名
  - メソッド名に書かれたのと真逆のことをするメソッド
  - 実際に格納されているよりも多くのものが含まれているかのごとき識別子名
  - 実際に格納されているよりも含まれているものが少ないかのごとき識別子名
  - 実際に格納されているものと真逆な識別子名
- 9.2.2 認知的負荷を測定する
  1. ごくごく低い心的努力
  2. ごく低い心的努力
  3. 低い心的努力
  4. 比較的低い心的努力
  5. 高くも低くもない心的努力
  6. 比較的高い心的努力
  7. 高い心的努力
  8. とても高い心的努力
  9. とてもとても高い心的努力

  - 目視での測定
  - 皮膚での測定
  - 脳での測定
- 9.2.3 言語的アンチパターンと認知的負荷
- 9.2.4 なぜ言語的アンチパターンは混乱をもたらすのか

### Chapter 10 複雑な問題をより上手に解決するために

#### 10.1 問題解決とは何か

- 10.1.1 問題解決を構成する要素
  - ゴール状態：何を達成したいかという目的となる状態。ゴールに到達したとき、その問題は解決した。
  - スタート状態：問題を解決するにあたってのスタートとなる状態
  - ルール：スタート状態からゴール状態に到達するための規定
- 10.1.2 状態空間
  - プログラムを解く時に考えうるすべてのステップ

#### 10.2 プログラミングの問題を解決する際に長期記憶はどのような役割を果たすのか

- 10.2.1 問題解決は、それ自体が認知プロセスなのか
- 10.2.2 長期記憶に問題解決を教える方法
  1. 問題を理解する
  2. 計画を立てる
  3. 計画を実行する
- 10.2.3 問題解決において重要な役割を担う2種類の記憶
  - 手続き記憶（潜在記憶）
  - 宣言的記憶（顕在記憶）

#### 10.3 自動化:潜在記憶の形成

- 10.3.1 時間経過と潜在記憶
  - 認知的段階
  - 連合的段階
  - 自律的段階
- 10.3.2 自動化するとなぜプログラミングが速くなるのか
- 10.3.3 潜在記憶の改善

#### 10.4 コードとその説明から学ぶ

- 10.4.1 新しいタイプの認知的負荷：学習関連負荷
  - レシピ（解き方）があったグループの方が成績が良い
  - ワーキングメモリーが枯渇せず、学習関連負荷が低い
- 10.4.2 実世界で範例を活用する
  - 同僚と共同作業をする
  - GitHubを探索する
  - ソースコードに関する本やブログ記事を読む

## Part 4 コーディングにおける共同作業

### Chapter 11 コードを書くという行為

#### 11.1 プログラミング中のさまざまな活動

- 11.1.1 検索
  - コードを調べ特定の情報を探す作業のことを指す
- 11.1.2 理解
  - コードを読んで実行し、その機能を把握することを意味する
- 11.1.3 転写
  - コードを書くという活動
- 11.1.4 増強
  - 検索と理解、転写をすべて組み合わせたもの
- 11.1.5 探索
  - スケッチを描くようにコードを書く
- 11.1.6 デバッグはどう分類するか
  - 5つの活動の混合

#### 11.2 中断されるプログラマー

- 11.2.1 プログラミング作業にはウォームアップが必要
- 11.2.2 割り込みが発生すると、その後どうなるのか
- 11.2.3 割り込みに備えるためのよい方法
  - メンタルモデルを保存する（メモを残す）
  - 展望記憶を補助する方法（TODOで残す）
  - 下位目標（Sub goal）のラベル付け（コメント）
- 11.2.4 プログラマーに割り込みを行う場合
- 11.2.5 マルチタスクに関するいくつかの考察
  - 認知的負荷の高い作業をマルチタスクでこなすことはできない

### Chapter 12 より大きなシステムの設計と改善

#### 12.1 コードベースの特性を調べる

- 12.1.1 認知の特性
  - エラーの発生のしやすさ
  - 一貫性
  - 拡散性：プログラムの長さ
  - 隠れた依存関係：依存関係がどのくらい見えるか
  - 暫定性：走りながら考えることが容易にできるか
  - 粘性：変更の難しさ
  - 段階的評価：部分的な作業のチェック
  - 役割表現力：役割を簡単に理解できるか
  - マッピングの近接度：コードの内容がビジネス領域にどれだけ近いか
  - ハードな心的操作：システム外
  - 副次的表記：コメントなど
  - 抽象化：システムの利用者がそのシステムに元からある抽象化と同等の抽象化を行えるかどうか
  - 視認性：システム内をどれだけ簡単に見ることができるか
- 12.1.2 CDCBを利用してコードベースを改善する
- 12.1.3 設計上の処置とそのトレードオフ

  |特性|助ける活動|害を及ぼす活動|
  |---|---|---|
  |エラーの発生のしやすさ||増強|
  |一貫性|検索、理解|転写|
  |拡散性|検索||
  |隠れた依存関係||検索|
  |暫定性|探索||
  |粘性||転写、増強|
  |段階的評価|探索||
  |役割表現力|理解||
  |マッピングの近接度|増強||
  |ハードな心的操作||転写、増強、探索|
  |副次的表記|検索||
  |抽象化|理解|探索|
  |視認性||理解|

#### 12.2 特性と活動

- 12.2.1 特性がそれぞれの活動に与える影響

- 12.2.2 想定される活動のためにコードを最適化する

#### 本章のまとめ

### Chapter 13 新しい開発者のオンボーディング

#### 13.1 オンボーディングプロセスにおける問題点

#### 13.2 熟達者と初心者の違い

- 13.2.1 初心者の行動をより深く理解する
  1. 感覚運動期
  2. 前操作期
  3. 具体的操作期
  4. 形式的操作期
- 13.2.2 概念を具体的に見るか抽象的に見るかの違い
  - 抽象 => 具体 => 抽象（一般化）

#### 13.3 オンボーディングプロセスを改善するための活動

- 13.3.1 タスクにおけるプログラミングに関する活動を1つに限定する
- 13.2.2 新人の記憶をサポートする
  - 長期記憶のサポート：関連情報を説明する
  - 短期記憶のサポート：小さくて1つのことだけに特化したタスクを用意する
  - 理解は開発よりも歓迎すべきタスクである
  - ワーキングメモリのサポート：ダイアグラムを描く
- 13.3.3 コードを一緒に読む
  1. 活性化：関連する事柄を積極的に考え、過去の知識を活性化させる
  2. 監視：文章の理解度を把握し続ける
  3. 重要性の判断：文章のどの部分が最も関連性が高いかを判断する
  4. 推論：文章にはっきりと書かれていない事実を補完する
  5. 可視化：読んだ文章の内容を図解して理解を深める
  6. 自問自答：その文章について質問を作り、それに答える
  7. 要約：文章の短い要約を作成する
