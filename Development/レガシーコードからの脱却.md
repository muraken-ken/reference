# レガシーコードからの脱却
## 第１部 レガシーコードの危機
### １章 何かが間違っている
#### レガシーコードとは何か？
- 保守や拡張が容易ではなく、お金がかかるソフトウェア

#### ウォーターフォール
- ウォーターフォール：物の製造には適している
  - 要求
  - 設計
  - 実装
  - 結合
  - テスト
  - インストール
  - 保守
- バグは結合フェーズ以降に大量に露見する

#### ウォーターフォールが機能しない理由
- 変更不可能なものができる（ソフトとハードの変更の数は全然違う）
- 未知の事柄を予測し減らそうとするとプロセスが複雑化する
- 開発とテストの分離
- 最後に進捗の遅れが露見する
- 設計書を書いても大して役に立たない
- 初期の設計フェーズ後に設計を変えるのは難しい

#### 素人業界
- ソフトウェアエンジニアリングは未確立

#### まとめ
- ほとんどのソフトウェアは作り方や保守の仕方を間違えている
- ソフトがどのように作られ、レガシーコードになるか、それを如何に防ぐかを知らない
- 機能をまとめてリリースすることは非効率である
- ウォーターフォールは、レガシーコードを作り出し拡散する
- ソフトウェアエンジニアリングは、基本原則や共通の知識体系をまだ確立していない

### ２章 CHAOSレポートの再考
#### プロジェクト失敗の要因
- コードの変更：容易に変更できないコードを書いている
- バグの修正：バグを見つけるのが難しいコードを書いている
- 複雑さの扱い：機能が多すぎて使わない機能も実装することで複雑になっている

#### 失敗のコスト
- プロジェクトの遅れ
- 保守、修正コスト
- 多額のお金が失われている
- 初期リリース後に発生する保守を含めたコスト全体が初期費用の5倍

### ３章 賢人による新しいアイデア
- アジャイルソフトウェア開発
  - リーンの概念（ジャストインタイム、自働化）
  - エクストリームプログラミング（XP）
  - 顧客満足を最優先し、価値あるソフトウェアを早く継続的に提供する

- 概念
  - 無駄をなくす：手をつけて完了していないものは無駄
  - 目標は小さいほどよい

- アジャイルがキャズムを超えつつある段階

## 第２部 ソフトウェアの寿命を延ばし価値を高める９つのプラクティス
### ４章 ９つのプラクティス
- ソフトウェア開発のプラクティスに従う必要があることを知っている
- 理解 → 実践 → 熟練（10000時間が必要）
- 第一原理
  - 単一責務の原則
  - オープン・クローズドの原則（拡張に対し開いていて、変更に対して閉じている）
- プラクティス
  - ほとんどの場合に価値があるものである
  - 学ぶのが容易である。教えるのが容易である。
  - 実施がシンプルである。考えなくてもやれるくらいにシンプルであること
- プラクティスの背後の原則の理解ができていれば、実践が容易
- 良いソフトウェアの定義
  - 変更が容易
  - 内部品質＞外部品質

### ５章 プラクティス１ やり方より先に目的、理由、誰のためかを伝える
- やり方は言わない
- ストーリーで目的を語る
  - 何が
  - なんのために
  - 誰のために存在する
- プロダクトオーナーにいてもらう
- 受け入れテストに明確な基準を設定し、テストを書く
  - 何をするはずか
  - いつ動くのか
  - どうなったら私たちは次に進めるのか
- 受け入れ基準を自働化する（テスト自働化）

#### プロダクトオーナーのための7つの戦略
- 専門家になる              ：内容をしっかり理解する
- 開発を発見のために利用する：フィードバックを活用し開発が正しい方向であることを確認
- なぜ誰のために、を開発者が理解できるようにする
- どうやって手に入れるのかではなく、何が欲しいのかを説明する
- 質問にすばやく答える
- 依存性を取り除く
- リファクタリングを後押しする

#### より良いストーリーを書くための7つの戦略
- プレースホルダー（仮置き場）として見る
- 目的に注目する
- 「誰」を擬人化する
- なぜ機能が必要とされたかを知る
- シンプルに始めて追加はあとで行う
- エッジケースを考える
- 受け入れ基準を利用する

### ６章 プラクティス２ 小さなパッチで作る
- 機能単位で作る方が単純でリスクも少ない
- 価値ある機能からリリース、柔軟に進める
- リリースサイクルが短いほど、効率が上がる
- 小さなタスク
  - 理解しやすい
  - 見積りやすい
  - 実装しやすい
  - テストしやすい
- 既知と未知を分割していく
- リスクを減らす唯一の方法は、開発したらシステムに完全に統合していまうこと
- フィードバックサイクルを短くする
- ビルドを高速化する
- フィードバックに対応し改善する
- バックログをつくる → 優先順位をつけ、並べ替える
- タスクの理想時間は4時間
- タイムボックスはきちんと終了させる
- スコープを管理する → カンバン

#### ソフトウェア開発を計測する7つの戦略
- 価値実現までの時間を計測する
- コーディングに使った時間を計測する
- 欠陥密度を計測する
- 欠陥検出までの時間を計測する
- 機能ごとの顧客価値を計測する
- 機能を提供しない場合のコストを計測する
- フィードバックループの効率を計測する

#### ストーリーを分割する7つの戦略
- 複数のことが混じったストーリーを要素に分解する
- 複雑なストーリーを既知のことと未知のことで分離する
- 未知のことをわかるまで繰り返す
- 受け入れ基準をもとに分解する
- 依存関係を最小にする
- 意図を1つにする
- ストーリーをテスト可能に保つ

### ７章 プラクティス３ 継続的に結合する
- 継続的インテグレーション
- 完了の違い
  - 完了            ：自分のマシンで実行し結果を得た
  - 完了の完了      ：ビルドに統合されている
  - 完了の完了の完了：クリーンで保守可能になっている
- 継続的にデプロイ可能にする
- ビルドを自働化する
- 早期から頻繁に統合する
- 初日からリリース可能であるべき

#### アジャイルインフラストラクチャーの7つの戦略
- すべてをバージョン管理する
- ワンクリックでエンドツーエンドのビルドをする
- 継続的に統合する
- タスクの受け入れ基準を定義する
- テスト可能なコードを書く
- 必要な場所のテストカバレッジを維持する
- 壊れたビルドをすぐ直す

#### リスクを減らす7つの戦略
- 継続的に統合する
- ブランチを避ける
- 自動テストに投資する
- リスクのある場所を特定する
- 未知の中で働く
- 価値がわかる最小のものを作る
- 頻繁に検証する

### ８章 プラクティス４ 協力しあう
- エクストリーミングプログラミング
- コミュニケーションと協働
- ペアプログラミング
  - コードが美しくなる
  - コードの共同所有が促される
  - 新たな参加者のスピードアップ
  - 品質向上
  - 割り込みが減少
  - 集中力が持続する
  - ロスは15%程度、メリットの方が大きい
  - なぜ？が大事
  - ペアはいろいろ試す
- バディプログラミング：短時間だけバディとレビューする、ペアプロのお試し
- スパイク  ：未知の課題解決のため1つのタスクにみんなで取り組む
- スウォーム：グループで取り組む
- モブ      ：普段からチームで一つのタスクに取り組む
- コードレビューとしてのレトロスペクティブのスケジュールを立てる
- 学習を増やし、知識を広げる
- 常にメンター、メンティーであれ

#### ペアプログラミングの7つの戦略
- やってみれば気に入る
- ドライバーとナビゲーターが参加する
- 役割を頻繁に交代する
- 正直な1日を過ごす
- すべての組み合わせを試す
- 詳細はチームで決める
- 進捗を追跡する

#### レトロスペクティブの7つの戦略
- 小さな改善を探す
- プロセスを責めよ。人を責めるな
- なぜなぜを5回やってみる
- 根本原因に取り組む
- 全員の意見を聞く
- 人に権限を
- 進捗を測ること

### ９章 プラクティス５ 「CREAN」コードを作る
- C：Cohesive（凝集性）
  - 単一責任の原則
- L：Loosely Coupled（疎結合）
- E：Encapsulated（カプセル化）
- A：Assertive（断定的）
- N：Nonredundant（非冗長）

#### コードの品質を上げる7つの戦略
- 品質の定義を明確にする
- 品質のためのプラクティスを共有する
- 完璧主義を手放す
- トレードオフを理解する
- 「やり方」を隠す
- 良い名前をつける
- コードをテスト可能に保つ

#### 保守しやすいコードを書く7つの戦略
- コードの共通所有を取り入れる
- リファクタリングを熱心に行う
- 常時ペアで進める
- 頻繁にコードレビューをする
- ほかの開発者のやり方を学ぶ
- ソフトウェア開発を学ぶ
- コードを読み書きして、コーディングの練習をする

### １０章 プラクティス６ まずテストを書く
- テスト
  - 受入テスト＝顧客テスト
  - ユニットテスト＝開発者によるテスト
  - それ以外のテスト＝QAテスト
    - コンポーネントテスト：ユニットの連携
    - 機能テスト：ユニットをまとめてエンドツーエンドのふるまい
    - シナリオテスト：ユーザーがシステムと対話する方法
    - パフォーマンステスト：負荷が高い時のテスト
    - セキュリティテスト：コードの脆弱性
- 良いテストを書く
  - テストはふるまい
- テスト駆動開発
  - すばやいフィードバックをもたらす
  - リファクタリングをサポートする
  - テスト可能なコードを書く

#### 優れた受け入れテストのための7つ戦略
- 作っているものが何に役立つのか明確にする
- 誰が何のために何をしたいのかを知る
- 受け入れ基準を自働化する
- エッジケース、例外、代替パスを表す
- 表示を使って詳細を具体化し、矛盾を一掃する
- 受け入れ基準とふるまいの分離
- 各テストを一意にする

#### 優れたユニットテストのための7つ戦略
- 呼び出し側の視点に立つ
- テストを使ってふるまいを表す
- 新しい違いを生み出すテストだけを書く
- 失敗したテストにパスするためのコードのみを書く
- テストを使って、ふるまいを作る
- コードをリファクタリングする
- テストをリファクタリングする

### １１章 プラクティス７ テストでふるまいを明示する
- テストファースト
  - レッド
  - グリーン
  - リファクタ
- テストファーストの例
  - テストを書く            ：レッド
  - コードをスタブアウトする：レッド
  - ふるまいを実装する      ：グリーン
- テストは仕様
- テストは一意であるべき
- コードをテストでカバーする
- バグにはテストがない
- モックを使ったワークフローテスト
- セーフティネットを作る

#### テストを仕様として使うための7つの戦略
- テストを文書のように扱えるようにする
- 意図がはっきりわかる名前のついたヘルパーメソッドを使う
- 何が重要なのかをを明らかにする
- 実装ではなくふるまいをテストする
- モックを使ってワークフローをテストする
- 書きすぎない
- 正確な例を使う

#### バグを修正する7つの戦略
- そもそもバグを作らない
- できるだけ早くバグを見つける
- バグを見つけられるように設計する
- 正しい質問をする
- バグをテストの不良と見なす
- 欠陥をもとにプロセスを修正する
- 失敗から学ぶ

### １２章 プラクティス８ 設計は最後に行う
- 変更しやすさへの障害
  - カプセル化の欠如
  - 継承の過度な利用
  - 具体的すぎる凝り固まった実装
  - インラインコード
  - 依存性
  - 作ったオブジェクトを使うか、使うオブジェクトを作るか
- 持続可能な開発
  - 死んだコードを消す
  - 名前を更新する
  - 判断を集約する
  - 抽象化
  - クラスを整頓する
- コーディング：テストにパスするコードを書く
- クリーニング：動くコードを保守可能にする
- ソフトウェアは書かれる回数より読まれる回数のほうが多い
- 意図によるプログラミング
  - 観点の一貫性：何をやるかは書くが、どうやるかは書かない
- 循環複雑度を減らす
  - 条件分岐は少ない方が良い
- 生成と利用を分離する
  - ポリモーフィズム
- 反復開発は設計を創発する

#### 創発設計をマスターする7つの戦略
- オブジェクト指向設計を理解する
- デザインパターンを理解する
- テスト駆動開発を理解する
- リファクタリングを理解する
- コードの品質にフォーカスする
- 情けはかけない
- 良い開発プラクティスを習慣にする

#### コードをクリーンにする7つの戦略
- コードに語らせる
- テストを足すために、接合部を作る
- メソッドの凝集性を高める
- クラスの凝集性を高める
- 判断を集約する
- ポリフォーフィズムを導入する
- 生成をカプセル化する

### １３章 プラクティス９ レガシーコードをリファクタリングする
- コストの削減
  - あとからコードを理解する
  - ユニットテストの追加
  - 新しい機能の追加
  - さらにリファクタリングする
- リファクタリング
  - コードを触る場合、意味がある
  - コードを触らないならやらない
- 変化しないソフトウェアは時代遅れになる
- レガシーコードの変更
  - 既存のコードへのテストの追加
  - 悪いコードをリファクタリングする
  - 不可避なことを先送りする（いつかはコードも死ぬ）
- リファクタリングのテクニック
  - ピンニングテスト（粗いテスト）
  - 依存性の注入：使用するオブジェクトをフレームワークに作成させてコードに注入
  - ストラングラーパターン：システムを止めずにコンポーネントをゆっくり置き換えていく
  - 抽象化によるブランチ
  - 規律あるリファクタリング
  - オープン・クローズの原則
- 2回目は適切にやる

#### リファクタリングから価値を得るための7つの戦略
- 既存のシステムを学ぶ
- 小さく改良する
- レガシーコードをテストで改良する
- クリーンアップをしながら進める
- 詳細がわかったら実装を再検討する
- 進む前にクリーンアップする
- やってはいけないことを学ぶリファクタリング

#### いつリファクタリングを行うかについての7つの戦略
- 重要なコードはうまく保守されていないとき
- コードを理解している人がいなくなったとき
- 新しい情報によって、より良い設計が見つかったとき
- バグを修正するとき
- 新機能を追加するとき
- レガシーコードのドキュメントを書くとき
- 作り直すより安い場合

### １４章 レガシーコードからの学び
- もっと良く速く安く
- 不要な出費はしない
- 真っすぐで狭いところを歩く
- ソフトウェア職のスキルを高める
- 理解を体現する
- 成長する勇気
- アジャイルの向こうへ