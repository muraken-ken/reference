# リーダブルコード
### 1章 理解しやすいコード
- __「コードは理解しやすくなければいけない」__
- __「コードは他の人が最短時間で理解できるように書かなければいけない」__
- __「このコードは理解しやすいだろうか？」と自問する__

## 第1部 表面上の改善
### 2章 名前に情報を詰め込む
- __名前に情報を詰め込む__
- 明確な単語を選ぶ
  - シソーラス（類語辞典）を活用
  |単語|代替案|
  |---|---|
  |send|deliver,dispatch,announce,distribute,route|
  |find|search,extract,locate,recover|
  |start|launch,create,begin,open|
  |make|create,set up,build,generate,compose,add,new|

- 汎用的な名前を避ける（あるいは、使う状況を選ぶ）
  - エンティティの値、目的を表した名前
  - tmp、val、retvalなどは避ける ← 名前に情報がない
  - tmp：生存期間が短く、一時的な保管が最も大切な変数に使う
  - ループイテレータ：i,j,k → member_i、mi が良い
- 抽象的な名前よりも具体的な名前を使う
  - 値の単位
  |関数の仮引数|単位を追加した仮引数|
  |---|---|
  |Start(int delay)|delay → delay_secs|
  |CreateCache(int size)|size → size_mb|
  |ThrottleDownload(float limit)|limit → max_kbps|
  |Rotate(int angle)|angle → degree_cw|

- 接尾辞や接頭辞を使って情報を付加する
  - その他の重要な属性を追加する
  |状況|変数名|改善後|
  |---|---|---|
  |passwordはプレインテキストなので、処理をする前に暗号化すべきである|password|plaintext_password|
  |ユーザが入力したcommentは表示する前にエスケープする必要がある|comment|unescapled_comment|
  |htmlの文字コードをUTF-8に変えた|html|html_utf8|
  |入力されたdataをURLエンコードした|data|data_urlenc|

- 名前の長さを決める
  - スコープが小さければ短い名前でもよい
  - 長い名前を入力するのは問題でない → editorが補完
  - 頭文字と省略形 → 新しいチームメイトが名前の意味を理解できるか？
  - 不要な単語を捨てる
- 名前のフォーマットで情報を伝える

### 3章 誤解されない名前
- __名前が「他の意味と間違えられることはないだろうか？」と何度も自問自答する__
- filter
  - 選択する：select
  - 除外する：exclude
- Clip(text, length)
  - 除外：remove
  - 切り詰め：truncate
  - max_chars, max_bytes
- 限界値を含めるときはmaxとminを使う
- 範囲を指定する時はfirstとlastを使う
- 包含／排他的範囲にはbeginとendを使う
- bool値の変数名の名前は、頭にis、has、can、shouldなどをつけてわかりやすくする
- ユーザの期待に合わせる
  - getは軽量アクセサ
  - sizeは値 → countするものだと時間がかかる
- 複数の名前を検討する

### 4章 美しさ
- __見た目が美しいコードの方が使いやすい__
- __一貫性のあるスタイルは「正しい」スタイルよりも大切だ__
- 一貫性のある簡潔な改行位置
- メソッドを使った整列
- 縦の線を真っすぐにする
- 一貫性と意味のある並び
- 宣言をブロックにまとめる
- コードを「段落」に分割する

### 5章 コメントすべきことを知る
- __コメントの目的は、書き手の意図を読み手に知らせることである__
- コメントするべきでは「ない」こと
  - __コードからすぐにわかることをコメントに書かない__
  - コメントのためのコメント
  - ひどい名前はコメントをつけずに名前を変える
ｰ コメントすること
  - コードを書いている時の自分の考えを記録する
    - 監督のコメンタリー
    - コードの欠陥
    |記法|典型的な意味|
    |---|---|
    |TODO:|あとで手をつける|
    |FIXME:|既知の不具合がある|
    |HACK:|あまりきれいじゃない解決策|
    |XXX:|危険！大きな問題がある|
  
    - 定数
- 読み手の立場になって考える
  - 質問されそうなことを想像する
  - ハマりそうな罠を告知する
  - 「全体像」のコメント
  - 要約コメント

### 6章 コメントは正確で簡潔に
- __コメントは領域に対する情報の比率が高くなければいけない__
- コメントを簡潔にしておく
- あいまいな代名詞を避ける
- 歯切れの悪い文章を磨く
- 関数の動作を正確に記述する
- 入出力のコーナーケースに実例を使う
- コードの意図を書く
- 「名前付き引数」コメント
- 情報密度の高い言葉を使う

## 第2部 ループとロジックの単純化
### 7章 制御フローを読みやすくする
- __条件やループなどの制御フローはできるだけ「自然」にする。コードの読み手が立ち止まっったり読み返したりしないように書く__
- 条件式の引数の並び順
|左側|右側|
|---|---|
|「調査対象」の式。変化する。|「比較対象」の式。あまり変化しない。|

- if/elseブロックの並び順
  - 条件は否定形よりも肯定形をを使う if (!debug) より if (debug)
  - 単純な条件を先に書く
  - 関心を引く条件や目立つ条件を先に書く
- 三項演算子
  - 基本的にはif/elseを使おう。三項演算子はそれによって簡潔になる時だけ使おう
  - __行数を短くするよりも、他の人が理解するのにかかる時間を短くする__
- do/whileループを避ける → whileループの方が理解しやすい
- 関数から早く返す
  - 複数のreturnを使う
  - クリーンアップコード
  |言語|クリーンアップコードのイディオム|
  |---|---|
  |C++|デストラクタ|
  |Java/Python|try...finally|
  |Python|with|
  |C#|using|

- 悪名高きgoto
- ネストを浅くする
  - __変更するときにはコードを新鮮な目で見る。一歩下がって全体を見る__
  - 早めに返してネストを削除する
  - ループ内部のネストを削除する
- 実行の流れを追えるかい？ → プログラム全体の流れ
|構成要素|高レベルの流れが不明瞭に|
|---|---|
|スレッド|どのコードがいつ実行されるのかよくわからない|
|シグナル／割り込みハンドラ|他のコードが実行される可能性がある|
|例外|いろんな関数呼び出しが終了しようとする|
|関数ポインタと無名関数|コンパイル時に判別ができないので、どのコードが実行されるのかわからない|
|仮想メソッド|object.virtualMethod()は未知のサブクラスのコードを呼び出す可能性がある|

### 8章 巨大な式を分解する
- __巨大な式は飲み込みやすい大きさに分割する__
- 説明変数
- 要約変数
- ド・モルガンの法則を使う
  - not (a or b or c) == (not a) and (not b) and (not a)
  - not (a and b and c) == (not a) or (not b) or (not c)
- 短絡評価の悪用 → if(a || b)
  - __「頭がいい」コードに気をつける。あとで他の人がコードを読むときにわかりにくくなる__
  - x = a || b || c ← a, b, cの中で最初に「真」と評価できるものを選ぶ

- 例：複雑なロジックと格闘する
  - より優雅（簡単）な手法を見つける
- 巨大な文を分割する
- 式を簡潔にするもう1つの想像的な方法 → C++でのマクロ

### 9章 変数と読みやすさ
- 変数のデメリット
  - 変数が多いと変数を追跡するのが難しくなる
  - 変数のスコープが大きいとスコープを把握する時間が長くなる
  - 変数が頻繁に変更されると現在の値を把握するのが難しくなる

- 変数を削除する
  - 役に立たない一時変数
    - 複雑な式を分割していない
    - より明確になっていない
    - 一度しか使っていないので、重複コードの削除になっていない
  - 中間結果を削除する
  - 制御フロー変数を削除する
- 変数のスコープを縮める
  - __変数のことが見えるコード行数をできるだけ減らす__
  - C++のif文のスコープ
  - JavaScriptで「プライベート」変数を作る
  - JavaScriptのグローバルスコープ
  - PythonとJavaScriptのネストしないスコープ
  - 定義の位置を下げる
- 変数は一度だけ書き込む → 定数を使う
  - __変数を操作する場所が増えると、現在値の判断が難しくなる__

## 第3部 コードの再構成
### 10章 無関係の下位問題を抽出する
- 抽出するための考え
  - 関数やコードブロックを見て「このコードの高レベルの目標は何か？」と自問する
  - コードの各行に対して「高レベルの目標に直接的に効果があるのか？ あるいは、無関係の下位問題を解決しているのか？」と自問する
  - 無関係の下位問題を解決しているコードが相当量あれば、それらを抽出して別の関数にする

- 純粋なユーティリティコード
- その他の汎用コード
- 汎用コードをたくさん作る
- プロジェクトに特化した機能
- 既存のインターフェイスを簡潔にする
- 必要に応じてインターフェイスを整える
- やりすぎ → 分けすぎると逆効果

### 11章 一度に１つのことを
- __コードは1つずつタスクを行うようにしなければならない__
  - コードが行っている「タスク」をすべて列挙する。
  - タスクをできるだけ異なる関数に分割する。

- タスクは小さくできる

### 12章 コードに思いを込める
- __おばあちゃんがわかるように説明できなければ、本当に理解したとは言えない__
  - コードの動作を簡単な言葉で同僚にもわかるように説明する
  - その説明のなかで使っているキーワードやフレーズに注目する
  - その説明に合わせてコードを書く

- ロジックを明確に説明する
- ライブラリを知る

### 13章 短いコードを書く
- __最も読みやすいコードは、何も書かれていないコードだ__

- その機能の実装について悩まないで－きっと必要ないから
- 質問と要求の分割
- コードを小さく保つ
  - 汎用的な「ユーティリティ」コードを作って、重複コードを削除する（10章）
  - 未使用のコードや無用の機能を削除する
  - プロジェクトをサブプロジェクトに分割する
  - コードの「重量」を意識する。軽量で機敏にしておく
- 身近なライブラリに親しむ
- コーディングするより、Unixツールボックスを使う

## 第4部 選抜テーマ
### 14章 テストと読みやすさ
- __他のプログラマが安心してテストの追加や変更ができるように、テストコードを読みやすくする__
- 大切ではない詳細はユーザから隠し、大切な詳細は目立つようにする
  - 最小のテストを作る
  - 独自の「ミニ言語」を実装する
- エラーメッセージを読みやすくする
  - もっとよいassert()を使う
  - 手作りのエラーメッセージ
- テストの適切な入力値を選択する
  - __コードを完全にテストする最も単純な入力値の組み合わせを選択しなければならない__
  - 入力値を単純化する
    - __テストには最もキレイで単純な値を選ぶ__
    - １つの機能に複数のテスト
- テストの機能に名前をつける
  - テストするクラス
  - テストする関数
  - テストする状況やバグ
- テストにやさしい開発
  - テスト容易性の低いコードの特性とそこから生じる設計の問題
|特性|テスト容易性の問題|設計の問題|
|---|---|---|
|グローバル変数を使っている|グローバルの状態をテストごとに初期化する必要がある|どの関数にどんな副作用があるのかわかりにくい。関数を個別に考えることができない。すべてが動くことを理解するにはプログラム全体を把握しないといけない。|
|多くの外部コンポーネントに依存している|最初に足場を設定しなければいけないので、テストを書くのが難しい。テストを書かなくなる。|依存しているものが落ちるとシステムが使えなくなる。任意の変更にどんな影響があるのかを理解するのが難しい。クラスのリファクタリングが難しい。システムが考えなければいけない故障状態や回復経路が増える。|
|コードが非決定的な動作をする|テストは当てにならず、信頼できない。|プログラムが競合状態になったり、再現不可能なバグが発生したりする。プログラムを論理的に判断できなくなる。バグを追跡したり修正したりするのが非常に難しい。|

  - テスト容易性の高いコードの特性とそこから生じる設計の利点
|特性|テスト容易性の利点|設計の利点|
|---|---|---|
|クラスが小さい。あるいは内部状態を持たない。|テストがしやすい。メソッドをテストするのにセットアップがあまり必要にならない。検査する状態が隠されていない。|状態の少ないクラスは単純で理解しやすい。|
|クラスや関数が1つのことをしている。|完全にテストをするためのテストケースが少なくて済む。|小さくて単純なコンポーネントがモジュール化されている。システムは疎結合である。|
|クラスは他のクラスにあまり依存していない。高度に疎結合化されている。|各クラスは独立してテストできる。|システムは並列的に開発できる。クラスは他の部分を気にすることなく簡単に修正や削除ができる|
|関数は単純でインターフェイスが明確である|明確な動作をテストできる。単純なインターフェイスなのでテストが楽。|インターフェイスがわかりやすくて再利用しやすい。|

- やりすぎ
  - テストのために本物のコードを犠牲にしてしまう
  - テストのカバレッジを100%にしないと気が済まない
  - テストがプロダクト開発の邪魔になる

### 15章 「分／時間カウンタ」を設計・実装する
## 解説
- 実際にやる
  - 実際にやるとぶつかること
  - 他の人に読んでもらう
- 当たり前にする
  - 既存のコードを読みやすくする前にやることは、これから書くコードを読みやすくする
  - 続けることが大事
- コードで伝える
  - コミットメール
  - まずはあなたが読む
  - 添削コミット
  - コードレビューをやる

