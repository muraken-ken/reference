# オブジェクト指向設計実践ガイド

## 第1章　オブジェクト指向設計

### 1.1 設計の賞賛
- オブジェクト指向設計＝費用対効果が高い・楽しい

#### 設計が解決する問題
- 変更は必ず必要：変更が容易なアプリケーション＝楽しい

#### 変更が困難な理由
- 部品：オブジェクト
- 相互作用：メッセージ
- 依存関係：メッセージを送るための知識が生み出す
- オブジェクト指向設計：「依存関係を管理すること」

#### 設計の実用的な定義
- 設計の難しさ
  - ユーザーに届ける機能のコードを作成する
  - その後の変更を受け入れられるものをつくる（変更の容易さが価値）

### 1.2 設計の道具
#### 設計原則
- SOLID
  - Single Responsibility：単一責任
  - Open-Closed：オープン・クローズド
  - Liskov Substiution：リスコフの置換
  - Interface Segregation：インターフェイス分離
  - Dependency Inversion：依存性逆転
- DRY：Don't Repeat Yourself
- LoD(Low of Demeter)：デメテルの法則
- 原則は先人の知恵：原則に従えば自身のコードを改善できる

#### 設計（デザイン）パターン
- 遭遇する問題：簡単でかつ明瞭な解を与える
- 設計プロダクト：柔軟性、モジュール性、再利用性、理解のしやすさを高める
- パターンは強力だが、適用するパターンを間違うと混乱することに注意

### 1.3 設計の行為
#### 設計が失敗する原因
- 設計が十分でない：変更に弱い
- 設計し過ぎる：不適切な場所への原則の適用
- 設計：斬新的な発見のプロセス
  - アジャイルソフトウェア運動：反復的な性質＝設計が定期的に調整され自然に進化

#### 設計をいつ行うか
- アジャイル：顧客との共同作業（少しづつ作り上げていく）
  - 変更が起る前提で進める
- 事前の全体設計(BDUF:Big Design Up Front)：意味を持たない

#### 設計を判断する
- ソフトウェアのメトリクス：あてにならない
- 技術的負債：将来の変更時に大きな工数がかかる

### 1.4 オブジェクト指向プログラミングのかんたんな導入
#### 手続き型言語
- 振る舞いとデータは別物：データは変数に納められ、振る舞いから振る舞いに渡される- データに対しては何でもできる：予測不可能で追跡できない
#### オブジェクト指向言語
- データと振る舞いを一つのオブジェクトにまとめる
- オブジェクトは互いにメッセージを送り合い、互いの振る舞いを決定する
- 振る舞いが同じでデータが異なる：クラス
- クラス
  - オブジェクトの構造の設計図
  - 振る舞い（メソッド）と変数（属性）を定義
  - インスタンス：クラスから生成

### 1.5 まとめ
- アプリケーションの最大の課題：「変更への対処」
- 変更の容易さ：「設計」の問題
- 良い設計：設計理論→実践に変換する能力による

## 第2章　単一責任のクラスを設計する
### 2.1 クラスに属するものを決める
#### メソッドをグループに分けクラスにまとめる
- 初期段階では知識が少なく困難
- 容易な変更が加えられるかが重要

#### 変更がかんたんなようにコードを組成する
- 変更が簡単であることの定義
  - 変更は副作用をもたらさない
  - 要件の変更が小さければ、コードの変更も相応して小さい
  - 既存のコードは簡単に再利用できる
  - 最も簡単な変更方法はコードの追加である。ただし、追加するコードはそれ自体変更が容易なものとする
- コードのあるべき姿(TRUE)
  - 見通しが良い(Transparent)：変更するコード、依存するコードにも変更がもたらす影響が明白である
  - 合理的(Reasonable)：変更にかかるコスト＜変更がもたらす利益
  - 利用性が高い(Usable)：新しい環境、予期しない環境でも再利用できる
  - 模範的(Exemlary)：コードに変更を加える人が、上記の品質を自然と保つようなコードになっている

### 2.2 単一の責任を持つクラスをつくる
#### アプリケーション例：自転車とギア
#### なぜ単一責任が重要なのか
- 変更が簡単＝再利用が簡単なクラス
  - 脱着可能なユニット
  - 明確に定義された振る舞い、依存が少ない
- 2つ以上の責任を持つクラス＝再利用が難しい
  - 再利用が難しい（必要な機能だけを抜け出せない）
  - 変更が起りやすい（責任範囲が広く、不明確なため）

#### クラスが単一責任かどうかを見極める
- クラスの持つメソッドを質問に言い換えてみる
- 1文でクラスを説明してみる（それとが含まれない、またははもっと悪い）
- オブジェクト設計思考では「凝集度」と表現する
- 単一責任の原則：責任駆動設計(RDD:Responsibility-Driven Design)

#### 設計を決定するときを見極める
- 今何もしない、将来のコストとの天秤
- 今すぐ改善、後で改善の天秤
- 時と場合による

### 2.3 変更を歓迎するコードを書く
#### データではなく，振る舞いに依存する
- DRYなコードは変更に寛容
- インスタンス変数の隠蔽（データへのアクセス）
  - インスタンス変数を直接参照
  - アクセサメソッドで包み隠す（変更に寛容）
= データ構造の隠蔽
  - メソッドで包み隠す（アクセサメソッドと同じ働き）

#### あらゆる箇所を単一責任にする
- メソッドから余計な責任を抽出する
  - メソッド：単一責任にする
  - リファクタリングで修正
- メリット
  - 隠蔽されていた性質を明らかにする
  - コメントをする必要がない
  - 再利用を推進する
  - 他のクラスへの移動が簡単
- クラス内の余計な責任を隔離する

### 2.4 ついに，実際のWheelの完成
### 2.5 まとめ

## 第3章　依存関係を管理する
### 3.1 依存関係を理解する
- 依存しているオブジェクト
  - 一方のオブジェクトに変更を加えたとき、他方のオブジェクトも変更が必要

#### 依存関係を認識する
- 以下の知っている時、依存関係がある
  - 他のクラスの名前
  - self以外のどこかに送ろうとするメッセージの名前
  - メッセージが要求する引数
  - それらの引数の順番
- 依存関係を管理し、依存を最低限にすること

#### オブジェクト間の結合（CBO：Coupling Between Objects）
- 2つ以上のオブジェクトの結合が強固な時、1つのユニットのように振る舞う

#### ほかの依存関係
- 「『何かを知るオブジェクト』」を知るオブジェクト」を知るオブジェクト
  - メッセージをチェーンのように繋いで、遠くのオブジェクトに依存
  - デメテルの法則に違反
- コードに対するテストの依存関係
  - コードと過度に結合したテストを書きがち

### 3.2 疎結合なコードを書く
- 依存：接着剤のようなもの、必要最低限にする

#### 依存オブジェクトの注入
- 依存オブジェクトの注入(DI:Dependency Injection)
```
 def gear_inches
   ratio * Wheel.new(rim, tire).diameter
 end

Gear.new(52, 11, 26, 1.5).gear_inches
```
```
 def gear_inches
   ratio * wheel.diameter
 end

Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inches
```

#### 依存を隔離する
- 完璧にできない場合は次善の策をとる
  - インスタンス変数の作成を分離する
  ```
  def initialize(chainring, cog, rim, tire)
    @chainring = chainring
    @cog = cog
    @wheel = Wheel.new(rim, tire)
  end
  ```  
  - wheelの作成を隔離する
  ```
  def gear_inches
    ratio * wheel.diameter
  end
  
  def wheel
    @wheel ||= Wheel.new(rim, tire)
  end
  ```
- 脆い外部メッセージを隔離する
```
def gear_inches
  ratio * wheel.diameter
end
```
```
def gear_inches
  ratio * diameter
end

def diameter #専用メソッドにカプセル化
  wheel.diameter 
end
```

#### 引数の順番への依存を取り除く
- 初期化の際の引数にハッシュを使う
```
def initialize(args)
  @chainring = args[:chainring]
  @cog = args[:cog]
  @wheel = args[:wheel]
end
```
- 明示的にデフォルト値を設定する
```
def initialize(args)
  @chainring = args[:chainring] || 40 # nilの場合エラー
  @cog = args.fetch(:cog, 18)         # nilでもOK
  @wheel = args[:wheel]
end
```
- 複数のパラメータを用いた初期化を隔離する
```
# 外部にIFをラップし、自身を変更から守る
module GearWrapper # ファクトリー
  def self.gear(args)
    SomeFramework::Gear.new(args[:chainring],
                            args[:cog],
                            args[:wheel])
  end
end

GearWrapper.gear(
  :chainring => 52,
  :cog => 11,
  :wheel => Wheel.new(26, 1.5)).gear_inches
```

### 3.3 依存方向の管理
#### 依存関係の逆転
- 将来の変更に備え正しい選択を行う

#### 依存方向の選択
- 変更の起きやすさを理解する
- 具象と抽象を認識する
  - 抽象(abstruct)：いかなる特定の実例（インスタンス）からも離れている
- 大量に依存されたクラスを避ける
- 問題となる依存関係を見つける
  - 自分より変更されないものに依存しなさい

### 3.4 まとめ

## 第4章　柔軟なインターフェースをつくる
- オブジェクト指向アプリ
  - クラスから成り立つ # クラスの集まりではない
  - メッセージにより定義される

### 4.1 インターフェースを理解する
- メッセージに明確に定義されたパターンはない
  - 再利用が困難
  - クラスは、どのメソッドも他のオブジェクトから正当に実行できる
- メッセージに明確に定義されたパターンはある
  - 脱着可能でコンポーネントのようなオブジェクトで構成
  - 制約がありオブジェクトが使えるメソッドが定義されている

### 4.2 インターフェースを定義する
#### パブリックインターフェース
- パブリックインターフェイス
  - クラスの主要な責任を明らかにする
  - 外部から実行されることが想定される
  - 気まぐれに変更されない
  - 他者がそこに依存しても安全
  - テストで完全に文書化されている

#### プライベートインターフェース
- プライベートインターフェース
  - 実装の詳細に関わる
  - 他のオブジェクトから送られてくることは想定されていない
  - どんな理由でも変更され得る
  - 他者がそこに依存するのは危険
  - テストでは、言及さえされないこともある

#### 責任，依存関係，そしてインターフェース

### 4.3 パブリックインターフェースを見つける
- パブリックインターフェイスを見つけ定義する＝1つの技巧
- ルールがなく設計上難しい
- 良くないインターフェイスのコストはすぐに明らかにならない

#### アプリケーション例：自転車旅行会社
#### 見当をつける
#### シーケンス図を使う
- シーケンス図：(UML:Unified Modeling Language)で定義

#### 「どのように」を伝えるのではなく「何を」を頼む
#### コンテキストの独立を模索する
#### ほかのオブジェクトを信頼する
#### オブジェクトを見つけるためにメッセージを使う
#### メッセージを基本とするアプリケーションをつくる

### 4.4 一番良い面（インターフェース）を表に出すコードを書く
- インターフェイスの明快さ＝設計スキル

#### 明示的なインターフェースをつくる
- 明示的にパブリックインターフェイスだと特定できる
- 「どのように」よりも「何を」になっている
- 名前は考えられる限り、変わり得ないものである
- オプション引数として、ハッシュをとる

#### ほかのパブリックインターフェースに敬意を払う
#### プライベートインターフェースに依存するときは，注意深くコンテキストを最小限にする

### 4.5 デメテルの法則
- デメテルの法則(LoD:Low of Demeter)
  - オブジェクトを疎結合にするためのコーディング規則の集まり

#### デメテルを定義する
- 3つ目のオブジェクトにメッセージを送る際に、異なる型の2つ目のオブジェクトを介することを禁止
  - 直接の隣人にのみ話かけよう
  - ドットは一つしか使わないようにしよう
- 事例
```
customer.bicycle.wheel.tire   # NG
customer.bicycle.wheel.rotate # NG
hash.keys.sort.join(', ')     # OK
```

#### 法則を違反することによる影響
#### 違反を回避する
- メッセージを移譲する
  - ラッパーメソッド（カプセル化、隠蔽）
  - 移譲（delegate.rb, forwardable.rb） # .は減らしたが根本解決はしていない

#### デメテルに耳を傾ける
### 4.6 まとめ

## 第5章　ダックタイピングでコストを削減する
- ダックタイピング：いかなる特定のクラスとも結びつかないパブリックインターフェイス
- クラスをまたぐインターフェイスはアプリケーションに大きな柔軟性をもたらす
  - クラスへの高コストな依存が、メッセージへのより寛容な依存で置き換えられる
  - そのクラスよりも振る舞いによって定義される
- 「もしオブジェクトがダックのように鳴き、ダックのように歩くならば、そのクラスが何であれ、それはダックである」
- 目的
  - アプリケーションに大きな柔軟性
  - アプリケーションにの変更のしやすさ

### 5.1 ダックタイピングを理解する
#### ダックを見逃す
#### 問題を悪化させる
#### ダックを見つける
#### ダックタイピングの影響
```
class Trip
  attr_reader :bicycle, :customer, :vehicle

  def prepare(preparers) # 記述はこれ以上増やさなくて良い
    preparers.each {|preparer|
      preparer.prepare_trip(self)}
  end
end

class Mechanic # クラスを増やせば機能が追加できる
  def prepare_trip(trip)
  end
end

class TripCoordinator
  def prepare_trip(trip)
  end
end

class Driver
  def prepare_trip(trip)
  end
end
```

- ポリモーフィズム(polymorphism)：多態性、多相性、多様性

### 5.2 ダックを信頼するコードを書く
#### 隠れたダックを認識する
- 置き換えられるもの
  - クラスで分岐するcase文
  - kind_of?とis_a?
  - responds_to?

#### ダックを信頼する
#### ダックタイプを文書化する
#### ダック間でコードを共有する
#### 賢くダックを選ぶ
- クラスが変更の可能性が低い（RubyのIntegerなど）の場合は例外

### 5.3 ダックタイピングへの恐れを克服する
#### 静的型付けによるダックタイプの無効化
- 型検査のデメリット：柔軟性を失う

#### 静的型付けと動的型付け
- 静的型付け
  - コンパイラがコンパイル時に型エラーを発見してくれる
  - 可視化された型情報は、文書の役割も果たしてくれる
  - コンパイルされたコードは最適化され、高速に動作する
- 動的型付け
  - コードは逐次実行され、動的に読み込まれる。コンパイル不要。
  - ソースコードは明示的な型情報を含まない
  - メタプログラミングがよりかんたん

#### 動的型付けを受け入れる
### 5.4 まとめ

## 第6章　継承によって振る舞いを獲得する
### 6.1 クラスによる継承を理解する
- 継承：メッセージの自動移譲の仕組み
  - クラスによる継承：クラシカル・インヘリタンス(classical inheritance)
  - Ruby:module、JavaScript：プロトタイプ等

### 6.2 継承を使うべき箇所を識別する
#### 具象クラスからはじめる
#### 複数の型を埋め込む
#### 埋め込まれた型を見つける
#### 継承を選択する
#### 継承関係を描く

### 6.3 継承を不適切に適用する

### 6.4 抽象を見つける
#### 抽象的なスーパークラスをつくる
- Bicycle
  - RoadBike
  - MountainBike

#### 抽象的な振る舞いを昇格する
#### 具象から抽象を分ける
#### テンプレートメソッドパターンを使う
#### すべてのテンプレートメソッドを実装する

### 6.5 スーパークラスとサブクラス間の結合度を管理する
#### 結合度を理解する
#### フックメッセージを使ってサブクラスを疎結合にする
- フックメッセージ：サブクラスがそれに合致するメソッドを実装することによって情報を提供
```
class Bicycle
  def initializa(args={})
    @size = args[:size]

    post_initialize(args) # フックメッセージ
  end

  def post_initialize(args) # デフォルト
    nil
  end
end

class RoadBike < Bicycle
  def post_initialize(args) # RoadBikeの場合
    nil
  end
end
```

### 6.6 まとめ

## 第 7 章　モジュールでロールの振る舞いを共有する
### 7.1 ロールを理解する
#### ロールを見つける
- オブジェクトが応答できるメッセージの集合
  - 自身が実装するメッセージ
  - 自身より、上の階層のすべてのオブジェクトで実装されるメッセージ
  - 自身に追加される、すべてのモジュールで実装されるメッセージ
  - 自身より上の階層のオブジェクトに追加される、すべてのすべてのモジュールで実装されるメッセージ

#### 責任を管理する
#### 不必要な依存関係を取り除く
#### 具体的なコードを書く
#### 抽象を抽出する
#### メソッド探索の仕組み
#### ロールの振る舞いを継承する

### 7.2 継承可能なコードを書く
#### アンチパターン
#### 抽象に固執する
#### 契約を守る
- リスコフの置換原則

#### テンプレートメソッドパターンを使う
#### 前もって疎結合にする
#### 階層構造は浅くする

### 7.3 まとめ

## 第 8 章　コンポジションでオブジェクトを組み合わせる
### 8.1 自転車をパーツからコンポーズする
#### Bicycleクラスを更新する
#### Parts階層構造をつくる
- Bycycle
  - Parts
    - MountainBikeParts
    - RoadBikeParts

### 8.2 Partsオブジェクトをコンポーズする
#### Partをつくる
#### Partsオブジェクトをもっと配列のようにする

### 8.3 Partsを製造する
#### PartsFactoryをつくる
#### PartsFactoryを活用する

### 8.4 コンポーズされたBicycle

### 8.5 コンポジションと継承の選択
#### 継承による影響を認める
#### コンポジションの影響を認める
#### 関係の選択
- is-a関係に継承を使う（A is-a B：AはBの一部である）
- behaves-like-a関係にダックタイプを使う（～のように振る舞う）
- has-a関係にコンポジションを使う （A has-a B：AはBを持っている）

### 8.6 まとめ

## 第9章　費用対効果の高いテストを設計する
- 変更可能なコードを書く＝技巧
  - オブジェクト指向設計の理解
  - コードのリファクタリングに長けている
    - リファクタリング：ソフトウェアの外部の振る舞いを保ったままで、内部の構造を改善していく作業
  - 価値の高いテストを書く能力

### 9.1 意図を持ったテスト
#### テストの意図を知る
- バグを見つける
- 仕様書となる
- 設計の決定を遅らせる
- 抽象を支える
- 設計の欠陥を明らかにする

#### 何をテストするかを知る
- プログラマーはテストを書きすぎている
  - テストの重複をなくす
  - パブリックインターフェイスに定義されるメッセージを対象

#### いつテストをするかを知る
- テストファーストで書く

#### テストの方法を知る
- テスト駆動開発(TDD)：内から外へテスト
- 振る舞い駆動開発(BDD:Behavior Driven Development)：外から内へテスト

### 9.2 受信メッセージをテストする
#### 使われていないインターフェースを削除する
#### パブリックインターフェースを証明する
#### テスト対象のオブジェクトを隔離する
#### クラスを使って依存オブジェクトを注入する
#### ロールとして依存オブジェクトを注入する

### 9.3 プライベートメソッドをテストする
#### テスト中ではプライベートメソッドを無視する
#### テスト対象クラスからプライベートメソッドを取り除く
#### プライベートメソッドのテストをするという選択

### 9.4 送信メッセージをテストする
#### クエリメッセージを無視する
#### コマンドメッセージを証明する

### 9.5 ダックタイプをテストする
#### ロールをテストする
#### ロールテストを使ったダブルのバリデーション

### 9.6 継承されたコードをテストする
#### 継承されたインターフェースを規定する
#### サブクラスの責任を規定する
#### 固有の振る舞いをテストする

### 9.7 まとめ