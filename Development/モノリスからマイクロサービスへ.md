# モノリスからマイクロサービスへ
## 1章 必要十分なマイクロサービス
### 1.1 マイクロサービスとは
- サービス指向アーキテクチャの一種（Service-Oriented Architecture）
  - 独立デプロイ可能性
  - ビジネスドメインに基づくモデル化
  - データベースを共有しない
  - メリット
    - 並行作業可
    - 多様な技術の選択可
    - 柔軟性
  - デメリット
    - レイテンシー（遅延時間）
    - より高くつく間違いを早く生む
  - ユーザーインターでフェースも分解する
  - 技術には依存しない
  - サイズは気にしない（可能な限り小さなインターフェースを持つ）
  - IT成果物とビジネスドメインの整合性、チームもビジネスドメインに合わせる

### 1.2 モノリス
- 単一プロセスのモノリス
  - 単一プロセス
  - モジュラーモノリス
- 分散モノリス
- サードパーティー製ブラックボックスシステム
- 課題
  - 所有権があいまい
  - 意思決定者があいあまい等
- 利点
  - シンプルなデプロイ方式
  - 監視、トラブルシューティング、テストが楽
  - コードの再利用が容易
  - モノリス ≠ レガシー 、モノリス ≠ 避けるべきもの

### 1.3 結合（Coupling）と凝集（Cphension）
- 他のサービスに変更を加えることなく本番環境にデプロイできる
- 凝集
  - 共にあり、共に変更されるコード
- 結合
  - 実装結合
  - 一時的結合
  - デプロイ時結合
  - ドメイン結合

### 1.4 必要十分なドメイン駆動設計
- ドメイン駆動設計（Domain-Driven Design:DDD）
  - 集約（Aggregate）
  - 境界づけられたコンテキスト（Bounded Context）

## 2章 移行を計画する
### 2.1 目的を理解する
- マイクロサービス ≠ 目的
  - 達成したいことは何か
  - マイクロサービスの他に代替案はなかったか
  - どうすれば移行がうまくいっているか分かるだろうか

### 2.2 マイクロサービスを選択する理由
- チームの自律性を高める
- 市場投入までの時間を減らす
- 負荷への費用対効果が高いスケーリング
- 堅牢性を改善する
- 開発者の数を増やす
- 新しい技術を受け入れる

### 2.3 マイクロサービスが悪いアイデアのとき
- ドメインが不明瞭
- スタートアップ
- 顧客の環境にインストールして管理するソフトウェア
- もっともな理由を持たないとき

### 2.4 トレードオフ
### 2.5 みんなを連れて行く
### 2.6 組織を変革する
- 危機意識を高める
- 変革推進のための連帯チームを築く
- ビジョンと戦略を生み出す
- 変革のためのビジョンを周知徹底する
- 従業員の自発を促す
- 短期的成果を実現する
- 成果を活かして、さらなる変革を推進する
- 新しい方法を企業文化に定着させる

### 2.7 段階的に移行していくことの重要性
- ビッグバンリライトをしても保証されるのはビッグバンだけ

### 2.8 変更のコスト
- 可逆的な判断と不可逆的な判断

### 2.9 どこから始めればよいか
### 2.10 ドメイン駆動設計
- ドメインモデルはどこから分解するか判断する材料が必要十分なレベルで良い
- イベントストリーミング
- ドメインモデルを使った優先順位付け

### 2.11 組み合わせモデル
- 分解いやすさ、分解による利益 でのマッピング

### 2.12 チームを再編成する
### 2.13 うまくいっているかどうかを分かるには

## 3章 モノリスを分割する
### 3.1 モノリスを変更すべきかどうか
### 3.2 移行パターン
### 3.3 ストラングラーアプリケーション
1. 移行対象を識別
2. 対象を移行する
3. 呼び出しをリダイレクトする

- 既存のシステムに変更加えず、移行が可能
  - HTTPリバースプロキシ

### 3.4 機能を移行しながら振る舞いを変える
### 3.5 UI合成
- ページ合成
- ウィジェット合成
- マイクロフロントエンド

### 3.6 抽象化によるブランチ
1. 置き換える機能の抽象を作る
2. 作成した抽象を使用するように既存機能のクライアントを変更する
3. 機能を改良した抽象の実装を新たに作る
4. 新しい実装を使用するように抽象を切り替える
5. 抽象を始末し、古い実装を削除する

### 3.7 同時実行
### 3.8 デコレーティングコラボレーター
### 3.9 変更データキャプチャ

## 4章 データベースを分割する
### 4.1 共有データベース
### 4.2 しかし、できない！
### 4.3 データベースレビュー
### 4.4 データベースをラップするサービス
### 4.5 サービスのインターフェイスとしてのデータベース
### 4.6 所有権を移す
### 4.7 データ同期
### 4.8 アプリケーションでのデータ同期
### 4.9 トレーサー書き込み
### 4.10 データベースを分割する
### 4.11 データベースとコードのどちらを最初に分割するか
### 4.12 スキーマ分割の例
### 4.13 テーブルの分割
### 4.14 外部キーのコードへの移動
### 4.15 トランザクション
### 4.16 サーガ

## 5章 成長の痛み
### 5.1 サービスが増えれば痛みも増える
### 5.2 所有権のスケール
- コード変更の障害

### 5.3 破壊的変更
- 契約違反

### 5.4 レポーティング
### 5.5 監視とトラブルシューティング
- サービスが増えると監視項目も増える

### 5.6 開発者体験
### 5.7 あまりにも多くのものを実行している
### 5.8 エンドツーエンドテスト
- 一貫したテストがしずらい

### 5.9 全体最適と局所最適
### 5.10 堅牢性と回復性
### 5.11 孤児サービス