# Clean Architecture 達人に学ぶソフトウェアの構造と設計
### まえがき
### 序文
## 第I部 イントロダクション
### 第1章 設計とアーキテクチャ
- 設計とアーキテクチャは同じ＝下位レベルの詳細と上位レベルの構造は全体の一部
#### 目的は？
- ソフトウェアアーキテクチャの目的は、求められるシステムを構築・保守するために必要な人材を最小限に抑えること
#### ケーススタディ
- 人員増→生産性減→変更コスト増
- 崩壊したコードを書く方がクリーンなコードを書くよりも常に遅い
- 速く進む唯一の方法は、うまく進むことである
- 自信過剰による再設計は、元のプロジェクトと同じように崩壊する
#### まとめ
### 第2章 2つの価値のお話
- ソフトウェアシステム => 「振る舞い」「構造」
#### 振る舞い
- 一般的にプログラマの存在理由と理解されている
#### アーキテクチャ
- ソフトウェアをソフトに保つため
- 変更の難易度は「形状」の違いではなく、「スコープ」に比例しなくてはならない
#### 大きな価値
- 機能＜アーキテクチャ ＝ 変更できることが価値
#### アイゼンハワーのマトリックス
1. 緊急(振る舞い)かつ重要（アーキテクチャ）
2. 緊急ではないが重要
3. 緊急だが重要でない：ココを↑に上げてはいけない
4. 緊急でも重要でもない
#### アーキテクチャの戦い
- 常に闘争である
## II部 構成要素から始めよ：プログラミングパラダイム
### 第3章 パラダイムの概要
#### 構造化プログラミング
- 直接的な制御の移行に規律を課すものである
  - gotoは有害
  - if/then/else, do/while/untilへ置き換え
#### オブジェクト指向プログラミング
- 間接的な制御の移行に規律を課すものである
#### 関数型プログラミング
- 代入に規律を課すものである
#### 考えるべきこと
- 何をすべきでないかを伝えている
  - goto文、関数ポインタ、代入を奪った
#### まとめ
- コンポーネントの分離、データ管理、機能 に対応（アーキテクトの関心事）
### 第4章 構造化プログラミング
#### 証明
- 制御構造：goto文をうまく使えば、選択（if/then/else）、反復（do/while/until）へ対応
- プログラムは「順次」「選択」「反復」の3つの構造で構築できる
- 上記を数学で証明した
#### 有害宣言
- GOTO文は有害だと考えられる（goto文が消えるきっかけ）
#### 機能分割
- 構造化プログラミング
  - モジュールを証明可能な単位に再帰的に分割することを可能にする
  - 大きな問題→上位で分割→下位で分割
  - モジュール→コンポーネント→証明可能な機能
#### 正式に証明できない
- 証明は不可能だった
#### 救済のための科学
- 科学的な方法：反証可能
- 真であることを証明することでなく、真でないことを証明することで機能
#### テスト
- テストはバグが存在することを示すものである
- テスト：プログラムが正しくないことを証明できるが、正しいことは証明できない
#### まとめ
- 機能分割がベストプラクティス
### 第5章 オブジェクト指向プログラミング
#### カプセル化とは？
- カプセル化に依存しているとは言えない
#### 継承とは？
- 以前から使われていた構造
#### ポリモーフィズムとは？
- ポリモーフィズムを安全かつ便利にしてくれた（関数ポインタの危険を排除）
  - デバイス非依存
  - 依存性逆転
#### まとめ
- ポリモーフィズムを使用することで、システムにあるすべてのソースコードの依存関係を絶対的に制御する能力
### 第6章 関数型プログラミング
#### 整数の二乗
- 関数型言語の変数は変化しない
#### 不変性とアーキテクチャ
- 可変変数がなければ、トラブルは少なくなる
#### 可変性の分離
- 「不変コンポーネント」「可変コンポーネント」を分離する
#### イベントソーシング
- 残高表示を取引のみで実現 → 十分な処理能力、十分なストレージがある
- アプリはCRUDではなくCRになる
#### まとめ
## 第III部 設計の原則
- SOLID原則：レンガを組み合わせて壁や部屋を作る方法
### 第7章 SRP：単一責任の原則
- モジュールを変更する理由はひとつだけであるべきである
- モジュールは立ったひとつのアクターに対して責務を負うべきである
- モジュール：凝集性
#### 症例1：想定外の重複
#### 症例2：マージ
#### 解決策
- アクターの異なるコードは分割すべきである
#### まとめ
### 第8章 OCP：オープン・クローズドの原則
- ソフトウェアの構成要素は拡張に対しては開いていて、修正に対して閉じていなければならない
#### 思考実験
#### 方向の制御
#### 情報隠蔽
#### まとめ
- コンポーネントAがコンポーネントBの変更から保護されるべきならば、コンポーネントBからコンポーネントAへ依存すべきである
### 第9章 LSP：リスコフの置換原則
- 個々のパーツが変更可能であること
#### 継承の使い方の指針
#### 正方形・長方形問題
#### リスコフの置換原則（LSP）とアーキテクチャ
#### リスコフの置換原則（LSP）違反の例
#### まとめ
- アーキテクチャにも適用すべき
### 第10章 ISP：インターフェイス分離の原則
#### インターフェイス分離の原則（ISP）と言語との関係
#### インターフェイス分離の原則（ISP）とアーキテクチャとの関係
#### まとめ
- 必要としないお荷物を抱えたものに依存していると、予期せぬトラブルの元になる
### 第11章 DIP：依存関係逆転の原則
- 依存したくない：変化しやすい具象
#### 安定した抽象
- 変化しやすい具象クラスを参照しない
- 変化しやすい具象クラスを継承しない
- 具象関数をオーバーライドしない
- 変化しやすい具象を名指しして参照しない
#### Factory
- Java：Abstruct Factory
#### 具象コンポーネント
#### まとめ
- ソースコードの依存性と処理の流れは逆向きになる
## 第IV部 コンポーネントの原則
- 部屋を組合わせて建物を作る方法
###  第12章 コンポーネント
- コンポーネント：デプロイの単位
- Java:jarファイル、Ruby:gemファイル、.NET:DLL
#### コンポーネントの簡単な歴史
#### リロケータビリティ（再配置可能性）
#### リンカ
#### まとめ
### 第13章 コンポーネントの凝集性
#### 再利用・リリース等価の原則（REP）
- 再利用の単位とリリースの単位は等価になる
#### 閉鎖性共通の原則（CCP）
- 同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること。変更の理由やタイミングが異なるクラスは、別のコンポーネントに分けること
- 単一責任の原則（SRP）のコンポーネント版
#### 全再利用の原則（CRP）
- コンポーネントのユーザーに対して、実際には使わないものへの依存を強要してはいけない
- インターフェイス分離の原則（ISP）を一般化したもの
#### コンポーネントの凝集性のテンション図
- 3つの原則には相反するところがある
- 3つの原則のバランスを取るのがアーキテクトの腕
#### まとめ
### 第14章 コンポーネントの結合
#### 非循環依存関係の原則（ADP）
- コンポーネントの依存グラフに循環参照があってはいけない
- 循環依存の解消
  - 依存関係逆転の原則を適用する
  - 両方が依存する新しいコンポーネントをつくる
#### トップダウンの設計
- コンポーネントをトップダウンで設計するのは無理
#### 安定依存の原則（SDP）
- 安定度の高い方向に依存すること
#### 安定度・抽象度等価の原則（SAP）
- コンポーネントの抽象度は、その安定度と同程度でなければならない
#### まとめ
## 第V部 アーキテクチャ
### 第15章 アーキテクチャとは？
- アーキテクトはプログラマでなければならない
- アーキテクチャの目的：ソフトウェアシステムの開発・デプロイ・通用・保守を容易にすること
- それらを容易にするための戦略は、できるだけ長い期間、できるだけ多くの選択肢を残すことである
#### 開発
#### デプロイ
#### 運用
#### 保守
#### 選択肢を残しておく
- 「振る舞いの価値」＜「構造の価値」
- 残すべき選択肢：重要でない詳細
  - 開発の初期段階でデータベースシステムを選択する必要はない
  - 開発の初期段階でウェブサーバーを選択する必要はない
  - 開発の初期段階でRESTを採用する必要はない
  - 開発の初期段階でDIフレームワークを導入する必要はない
- 延期する→適切に作るための情報が数多く手に入る
#### デバイス非依存
#### ダイレクトメール
#### 物理アドレス
#### まとめ
### 第16章 独立性
- アーキテクチャがサポートする項目
  - ユースケース
  - 運用
  - 開発
  - デプロイ
#### ユースケース
#### 運用
#### 開発
#### デプロイ
#### 選択肢を残しておく
#### レイヤーの切り離し
#### ユースケースの切り離し
#### 切り離し方式
#### 独立した開発が可能
#### 独立デプロイ可能性
#### 重複
#### 切り離し方式（再び）
- ソースレベル
- デプロイレベル
- サービスレベル
#### まとめ
### 第17章 バウンダリー：境界線を引く
- ソフトウェアアーキテクチャ：境界線を引く技芸
#### 結合の悲しい物語
#### FitNesse
#### あなたの境界線は何か？　いつ境界線を引くのか？
#### 入力と出力はどうする？
#### プラグインアーキテクチャ
#### プラグインの戦い
#### まとめ
- 境界線を引く：システムをコンポーネントに分割する
- いくつかのコアコンポーネントがビジネスルールになる
### 第18章 境界の解剖学
#### 境界を越える
- ソースコードの依存関係の管理
#### 恐怖のモノリス
#### デプロイコンポーネント
#### スレッド
#### ローカルプロセス
#### サービス
#### まとめ
### 第19章 方針とレベル
#### レベル
- レベル：入力と出力からの距離
- 離れていればより高レベル
- ソースコードの依存性は、レベルと結びつけるべき
#### まとめ
### 第20章 ビジネスルール
- 最重要ビジネスルール：システムが存在していなくても存在するビジネスルール
- 最重要ビジネスデータ：最重要ビジネスルールに付属するデータ
#### エンティティ
- システム内部のオブジェクト＝ビジネス
#### ユースケース
- アプリケーション固有のビジネスルール
#### リクエストとレスポンスのモデル
#### まとめ
### 第21章 叫ぶアーキテクチャ
#### アーキテクチャのテーマ
#### アーキテクチャの目的
- 優れたアーキテクチャはユースケースを中心にしている
- フレームワークの選択肢は残されたまま
#### だが、ウェブはどうか？
- ウェブはIO
#### フレームワークはツールであり、生き方ではない
#### テスト可能なアーキテクチャ
#### まとめ
### 第22章 クリーンアーキテクチャ
![Clean Architecture](C:\Users\muraken\Documents\07.プログラミング学習\references\Development\Clean Architecture\Clean_Architecture.jpg)
#### 依存性のルール
- ソースコードの依存性は、内側（上位レベルの方針）だけに向かっていなければいけない
  - エンティティ：企業全体の最重要ビジネスルールをカプセル化したもの
  - ユースケース：アプリケーション固有のビジネスルール
  - インターフェイスアダプター：プレゼンター、ビュー、コントローラ
  - フレームワークとドライバ
#### 典型的なシナリオ
#### まとめ
### 第23章 プレゼンターとHumble Object
#### Humble Objectパターン
- ユニットテストがしにくいテストを分離
#### プレゼンターとビュー
- プレゼンター：テスト可能
- ビュー：テストしにくい
#### テストとアーキテクチャ
#### データベースゲートウェイ
#### データマッパー
#### サービスリスナー
#### まとめ
### 第24章 部分的な境界
#### 最後のステップを省略する
#### 片方だけの境界
#### Facade
#### まとめ
### 第25章 レイヤーと境界
#### Hunt the Wumpus
#### クリーンアーキテクチャ？
#### 流れを横切る
#### 流れを分割する
#### まとめ
### 第26章 メインコンポーネント
#### 究極的な詳細
#### まとめ
### 第27章 サービス：あらゆる存在
#### サービスアーキテクチャ？
#### サービスのメリット？
#### 子猫の問題
#### 救世主のオブジェクト
#### コンポーネントベースのサービス
#### 横断的関心事
#### まとめ
### 第28章 テスト境界
#### システムコンポーネントとしてのテスト
#### テスト容易性のための設計
#### テストAPI
#### まとめ
### 第29章 クリーン組込みアーキテクチャ
#### 適性テスト
#### ターゲットハードウェアのボトルネック
#### まとめ
## 第VI部 詳細
### 第30章 データベースは詳細
#### リレーショナルデータベース
#### なぜデータベースシステムが普及しているのか？
#### もしもディスクがなかったら？
#### 詳細
#### だけど、パフォーマンスはどうなの？
#### 小話
#### まとめ
### 第31章 ウェブは詳細
#### 止まらない振り子
#### 結論
#### まとめ
### 第32章 フレームワークは詳細
#### フレームワークの作者たち
#### 一方的な結婚
#### リスク
#### 解決策
#### 今あなたたちを夫婦として宣言する
#### まとめ
### 第33章 事例：動画販売サイト
#### プロダクト
#### ユースケース分析
#### コンポーネントアーキテクチャ
#### 依存性管理
#### まとめ
### 第34章 書き残したこと
#### レイヤーによるパッケージング
#### 機能によるパッケージング
#### ポートとアダプター
#### コンポーネントによるパッケージング
#### 悪魔は実装の詳細に宿る
#### 組織化かカプセル化か
#### そのほかの分割方法
#### まとめ：言い残したこと
## 第VII部 付録
### 付録A アーキテクチャ考古学
#### 組合の会計システム
#### レーザーカット
#### アルミダイキャストの監視
#### 4-Tel
#### サービスエリアコンピュータ
#### C言語
#### BOSS
#### pCCU
#### DLU/DRU
#### VRS
#### 電子受付
#### 転送システムの作成
#### 明確なコミュニケーション
#### ROSE
#### アーキテクト登録試験
#### まとめ
## あとがき
### 訳者あとがき
### 訳者について