# Clean Code アジャイルソフトウェア達人の技
## まえがき
- 「小さなことに誠実であることは、決して小さなことではない。」
- 「神は細部に宿る」（建築家：ルートヴィッヒ・ミース・ファン・デル・ローエ）
- 1950年 TPM（Total Producetive Maintenance）
  - 5S
    - 整理
    - 整頓
    - 清掃
    - 清潔
    - しつけ

## 序論
- 職人技：身につけるには努力が必要
  - 知識
  - 作業

- 職人技
  - 原則
  - パターン
  - 実践
  - 経験則

## 第1章 クリーンコード
- 粗悪なコード：会社を廃業に追い込むこともある
- 混乱のために支払う総コスト：高くつく
- 途中で基礎設計をやり直す：旧システム→新システム
- 心構え：綺麗なコードを保つのは自分
- 最初の難問：納期を守るために混乱を埋め込むことは逆効果
- クリーンコード技法とは？：小さな手法を規律を持って適用する
- クリーンコードとは？
  - エレガント：心地よさ
  - 単純で直接的：読みやすさ
  - 作者意外が読め、拡張できる
  - 気配りをもって書かれている
  - 全てのテストを実行する／重複がない／設計知識が表現されている／クラス／メソッド／関数
  - 予想を上回るもの
  - 読みやすくする＝書きやすくする
- ボーイスカウトの規則：キャンプ場を自分が見つけたときよりもきれいにすること

## 第2章 意味のある名前
- 意図が明確な名前にする
- 偽情報を避ける：不適切な名前は混乱の原因
- 意味ある対比を行う
  - 適当な数字（ノイズワード）
  - info、dataなどはっきりしない単語
- 発音可能な名前を使用する（略語は危険）
- 検索可能な名前を用いる
  - 1文字の名前
  - 数値定数
- エンコーディングを避ける
- ハンガリアン記法
- メンバープレフィクス
- インターフェイスと実装
- メンタルマッピングを避ける：コードを読む人が心の中で既知の名前に変換しなけらばならない
- クラス名：名詞、名詞句
- メソッド名：動詞、動詞句
- 気取らない：単純明快で意図が伝わる言葉を使う
- 1つのコンセプトには1つの単語
- ごろ合わせをしない
- 解決領域の用語の使用：OK
- 問題領域の用語の使用：OK
- 意味ある文脈を加える：OK
- 根拠のない文脈を与えない

## 第3章 関数
- 小さいこと！
  - ブロックとインデント：ネストは少なく
- 1つのことを行う：関数では1つのことを行うようにせよ。その1つのことをきちんと行い、それ以外のことを行ってはならない。
  - 関数内のセクション：NG
- 1つの関数に1つの抽象レベル
  - コード通読：逓減規則 上から下へと読める
  - switch文：低レベルの処理に使い、繰り返さない
- 内容をよく表す名前を使う
- 関数の引数
  - 共通モナディック形式
  - フラグ引数：NG
  - 引数2つの関数
  - 引数3つの関数
  - 引数オブジェクト
  - 引数リスト
  - 動詞とキーワード
- 副作用を避ける
  - 出力引数
- コマンド・照会の分離原則
  - try/catchブロックの分離
  - エラー処理も一つの処理
  - Error.java依存性磁石
- DRY(Don't Repeat Yuorself)原則
- 構造化プログラミング：関数が小さければ役に立たない

## 第4章 コメント
- 基本コメントは書かないのが理想（最小限）
- コメントで、ダメなコードを取り繕うことはできない
- 自分自身をコードの中で説明する
- よいコメント
  - まっとうなコメント：著作権、著作者など
  - 情報を与えるコメント
  - 意図の説明
  - 明確化
  - 結果に対する警告：時間がかかるなど
  - TODOコメント（基本はその場で対処がベスト）
  - 強調
  - 公開APIにおけるJavadoc
- よくないコメント
  - ぶつぶついう
  - 冗長なコメント
  - 誤解を招くコメント
  - 命令コメント
  - 日誌コメント
  - ノイズコメント
  - 恐るべきノイズ
  - 関数や変数が使用できるのであれば、コメントを使用しないこと
  - 道標
  - 閉じかっこコメント
  - 属性と署名
  - コメントアウトされたコード
  - HTMLコメント
  - 非局所的な情報
  - 多すぎる情報
  - 不明確なつながり
  - 関数ヘッダ
  - 非公開コードのJavadoc

## 第5章 書式化
- 書式化の目的：重要→読みやすさ、保守性
- 縦方向の書式化
  - 新聞にたとえる：見出しで内容がわかり、詳細はその下に書かれている
  - 垂直概念分離性：空行の入れ方
  - 垂直密度：適度にまとめる、余計な空白やコメントで分離しない
  - 垂直距離：関連するコードが離れすぎない
  - 垂直方向の並び順
- 横方向の書式化
  - 水平分離度と密度
  - 水平方向の位置合わせ：あまり有用ではない
  - インデント
  - ダミーのスコープ
- チームの規則
- アンクルボブの書式化規則

## 第6章 オブジェクトとデータ構造
- データ抽象化
- データ／オブジェクトの非対称性
  - 手続き型（データ構造を使用するコード）
    - 新たな関数を既存のデータ構造に影響を与えずに追加することがでる
    - 新たなデータ構造を追加するには、既存のすべての関数を変えなければならない
  - オブジェクト指向
    - 既存の関数を変えることなく、新たなクラスを追加することができる
    - すべてのクラスを変えなければならないので、新たな関数を追加することは難しくなる
  - データ構造<-->オブジェクト指向
    - 複雑なシステムでは、新たな関数を追加することよりも、新たなデータ型を追加することのほうが多い => オブジェクト指向
- デメテルの法則：オブジェクトを使用する場合、オブジェクトの内部について知るべきではない
  - 電車の衝突：メソッドの呼び出しチェイン => 分けるべき
  - 混血児：データ構造とオブジェクトの混ざったもの
  - 隠蔽構造：異なるレベルの情報を一緒くたに扱わない
- データ転送オブジェクト
  - アクティブレコード

## 第7章 エラー処理
- returnコードではなく、例外を使用する
- 最初にtry-catch-finally文を書く
- 非チェック例外を使用する
- 例外で状況を伝える
- 呼び出し元が必要とする例外クラスを定義する
- 正常ケースのフローを定義する
- nullを返さない
- nullを渡さない

## 第8章 境界
- サードパーティのコードを使用する
- 境界の調査と学習
  - 学習テストを書いてみる
- 学習テストはタダ以上のものである
- まだ存在しないコードを利用する
- きれいな境界

## 第9章 単体テスト
- TDD三原則
  - 第一則：失敗する単体テストを書く前に、製品のコードを書いてはならない
  - 第二則：コンパイルが通り、適切に失敗する単体テストができるまでは、次の単体テストを書いてはならない
  - 第三則：現在失敗している単体テストが通るまで、次の製品コードを書いてはならない
- テストをきれいに保つ
  - テストは、xxx性を可能とする
    - 改善・変更が可能
- クリーンテスト
  - 読みやすさ
  - ドメイン特化テスト言語
  - 二重規範
- 1つのテストに1つのアサート
  - 1つのテストでは1つの概念を扱う
- F.I.R.S.T
  - Fast：高速である
  - Independent：独立している
  - Repeatable：再現性がある
  - Self-Validating：自己検証可能
  - Timely：適時性がある

## 第10章 クラス
- クラスの構成
  - カプセル化：変数、ユーティリティ関数をprivate（テストのためにprotectedにするケースもある）
- クラスは小さくしなければならない
  - 単一責務の原則(Single Responsibility Principle:SRP)：クラス、モジュールは変更の原因となるものが1つでなければならない
  - 凝集性：高めるためにはクラスを分轄して小さくする
  - 凝集性に気を配ると、大量の小さなクラスが生まれる
  - 変更のために最適化する
    - 変更から切り離す：インターフェイスと抽象クラス

## 第11章 システム
- あなたは、街をどうやって造りますか？
- システムを使うことと、構築することとを分離する
  - mainの分離
  - ファクトリ
  - 依存性注入(Dependency ionjection:DI)
- スケールアップ
  - 横断的関心事
- Javaプロキシ
- Pure JavaのAOPフレームワーク
- AspectJアスペクト
- システムアーキテクチャのテスト実行
- 意思決定を最適化する
- 検証可能な価値を追加する際には、標準を賢く使用する
- システムはドメイン特化言語を必要とする

## 第12章 創発
- 創発的設計を通して、洗練する
  - 全テストを実行する
  - 重複がない
  - プログラマの意図が表現されている
  - クラスとメソッドを最小化する
- 単純な設計への規則1：全テストを実行する
- 単純な設計への規則2～4：リファクタリング
  - 重複の排除
  - 表現に富む
  - クラスとメソッドを最小限に 

## 第13章 同時並行性
- なぜ同時並行性が必要なのか？
  - 神話と誤解
    - 同時並行性は常にパフォーマンスを改善する：状況による
    - 同時並行プログラムを書く場合には設計の変更は不要である：システムの構造に大きな影響がある
    - Web、EJBといったコンテナで作業するのであれば、同時並行性の問題を理解することは大して重要ではない：デッドロックに注意
    - 余分なオーバーヘッドがつきまとう
    - 問題が単純でも同時並行性の確保は複雑となる
    - 同時並行性のバグは再現性がなく、一過性の問題として片付けられる
    - 同時並行性の実現のため、設計戦略の根幹の変更をしならればならい
- 同時並行性防御原則
  - 単一責務の原則
  - 帰結：データのスコープを限定せよ
  - 帰結：データのコピーを使用せよ
  - 帰結：スレッドはできるかぎり独立させよ
- 使用しているライブラリを知る
  - スレッドセーフなコレクション
- 実行モデルを見分ける
  - プロデューサーコンシューマ
  - リーダー・ライター
  - 哲学者の食事
- 同期化メソッド間の依存関係に注意
- 同期化セクションを小さくする
- 正確な処理コードを書くのは難しい
- スレッド化されたコードのテスト
  - 怪しい失敗を、スレッド問題の容疑者として扱う
  - 最初にスレッド化されていないコードを完成させる
  - スレッド化されたコードは差し替え可能とする
  - スレッド化されたコードをチューニング可能にしておく
  - プロセッサの数よりスレッドの数を多くする
  - 異なるプラットフォームで実行する
  - コードに対していろいろなことを試し、強制的にエラーを発生させる
  - 手作業によるもの
  - 自動的に行うもの
  
## 第14章 継続的改良（コマンドライン引数のパーサを用いたケーススタディ）
- Javaコードの書き方実例

## 第15章 JUnitの内部
- Javaコードの書き方実例

## 第16章 SerialDateのリファクタリング
- Javaコードの書き方実例

## 第17章 においと経験則
- コメント
  - 不適切な情報
  - 退化コメント
  - 冗長なコメント
  - 記述不足のコメント
  - コメントアウトされたコード
- 環境
  - ビルドに複数のステップを要する
  - テストに複数のステップを要する
- 関数
  - 多すぎる引数
  - 出力引数
  - フラグ引数
  - 死んだ関数
- 一般
  - 1つのソースのファイルに複数の言語を使用する
  - あって当然の振る舞いが実装されていない
  - 境界値に対する不正確な振る舞い
  - 安全軽視
  - 重複
  - 抽象レベルが正しくないコード
  - 継承クラスに依存したベースクラス
  - 情報過多
  - デッドコード
  - 垂直分離
  - 不整合
  - 雑然
  - 人為的な結合
  - 機能の羨望
  - セレクタ引数
  - 不明瞭な意図
  - 責務を持たせる場所の間違い
  - 不適切なstatic
  - 説明的変数
  - 関数名は体を表すべき
  - アルゴリズムを理解する
  - 論理的な依存性を物理的なものとする
  - if/elseやswitch/caseよりも多態を好む
  - 標準の規約に従う
  - マジックナンバーを名前付けした定数に置き換える
  - 正確であれ
  - 規約より構造
  - 条件をカプセル化せよ
  - 条件の否定形を避ける
  - 関数では1つのことを行うべき
  - 隠れた時間軸上の結合
  - いいかげんにならないこと
  - 境界条件はカプセル化する
  - 関数は1つの抽象レベルを担うべき
  - 設定可能なデータは高いレベルに置く
  - 推移的なナビゲーションを避ける
- Java
  - ワイルドカードを使って、長いimportのリストを避ける
  - 定数を継承しない
  - 定数とenum
- 名前
  - 記述的な名前を選ぶ
  - 抽象レベルに適切な名前を選ぶ
  - 可能な限り標準の用語を使用する
  - はっきりした名前
  - 広いスコープには長い名前を
  - エンコーディングを避ける
  - 名前で副作用を示すべき
- テスト
  - 不十分なテスト
  - カバレッジツールを使用する
  - ささいなテストを省略しない
  - 無視することを指定されたテストは、あいまいさへの問いかけである
  - 境界条件テスト
  - バグの周辺は徹底的にテストを
  - 失敗パターンは何かを語る
  - テストカバレッジのパターンは何かを語る
  - テストは高速に実行できるべき