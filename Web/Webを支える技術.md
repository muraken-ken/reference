# Webを支える技術
## 第1部 Web概論
### 第1章 Webとは何か
#### 1-1. Webの用途
- Webサイト       ：一般的
- UIとしてWeb     ：ルーターなどの設定画面
- APIとしてのWeb  ：XML、JSONなどプログラム用I/F

#### 1-2. Webを支える技術
- HTTP、URI、HTML
- ハイパーメディア（リンクで様々なメディアを接続したシステム）
- 分散システム <=> 集中システム

### 第2章 Webの歴史
#### 2-1. Webの誕生
- Berners-Lee氏の発案・実装
- RFC、W3Cにて仕様の標準化

#### 2-2. RESTの誕生
- Roy Fielding氏の論文
  - REST(REpresentational State Transfer)：Webサービスの設計モデル
- REST > SOAP、WS-*

### 第3章 RESTのアーキテクチャスタイル
#### 3-1. アーキテクチャスタイル
- アーキテクチャスタイル：REST
- アーキテクチャ：ブラウザ、サーバー、プロキシ、HTTP、URI、HTML
- 実装：Apache、Firefox、IE

#### 3-2. リソース
Web上に存在する情報 ← URIでアドレス可能性が増した

#### 3-3. REST
- REST ＝<br>
クライアント／サーバーモデル<br>
＋ステートレスサーバー（クライアントの状態を保持しない）<=> Cookieのsession保持はRESTに反する<br>
＋キャッシュ（情報をクライアントで保持、情報量が減る）<br>
＋統一インターフェース（HTTP）<br>
＋階層化システム<br>
＋コードオンデマンド（JavaScript等、必要な時にDLし実行）

- RESTはハイパーメディアと相性が良い => URI
- RESTは分散システムと相性が良い => HTTPで簡潔なやりとり
- RESTに準拠した => 『RESTful』<br>
※ Cookieによるsession状態はRESTでない

## 第2部 URI
### 第4章 URIの仕様
#### 4-1. 仕様
- URI(Uniform Resource Identifier)<br>
http://yohei:pass@blog.example.jp:8888/search?q=test&debug=true#n10
  - URIスキーム：http
  - ユーザー情報：youhei.pass
  - ホスト名：blog.example.jp
  - ポート番号：8888
  - パス：/search
  - クエリパラメータ：q=test&debug=true
  - URIフラグメント：#n10

- 使用できる文字
  - アルファベット：A-Za-z
  - 数字：0-9
  - 記号：-.~:@!$&'()

#### 4-2. 注意点
- 絶対URIと相対URIが使えるが絶対URIが基本
- 文字エンコーディングはutf-8が基本（その他のエンコーディングは%を使用）

#### 4-3. URLとURN
- URI = URL + URN

### 第5章 URIの設計
#### 5-1. URIの設計指針
- URIにプログラミング言語依存の拡張子を利用しない
- URIに実装依存のパス名を利用しない
- URIにプログラミング言語のメソッド名を利用しない
- URIにセッションIDを含めない
- URIは、そのリソースを表現する名詞である

### 5-2. クールなURI
- 変わらない
- シンプルで覚えやすい

#### 5-3. 設計テクニック
- 変更：リダイレクト
- 拡張子で表現を指定
- マトリクスURI

## 第3部 HTTP
### 第6章 HTTPの基本
#### 6-1. プロトコルの階層
- アプリケーション層：HTTP、NTP、SSH、SMTP、DNS
- トランスポート層：TCP <= 相手にコネクション、データ漏れをチェック
- インターネット層：IP <= パケット単位でデータをやり取り（送信のみ）
- ネットワークインターフェース層：イーサネット（物理層）

#### 6-2. HTTP
- HTTP1.1が最新
- HTTP：クライアント／サーバー => リクエスト／レスポンス型

#### 6-3. クライアントの基本動作
1. リクエストメッセージの構築
2. リクエストメッセージの送信
3. 待機
4. レスポンスメッセージの受信
5. レスポンスメッセージの解析
6. クライアントの目的を達成するために必要な処理

#### 6-4. サーバーの基本動作
1. 待機
2. リクエストメッセージの受信
3. リクエストメッセージの解析
4. 適切なアプリケーションプログラムへの処理の移譲
5. アプリケーションプログラムから結果を取得
6. レスポンスメッセージの構築
7. レスポンスメッセージの送信

#### 6-5. HTTPメッセージ
- リクエストメッセージ
  1. リクエストライン：メソッド＋リクエストURI＋プロトコルバージョン＋テキストフレーズ
  2. ヘッダ：メタデータ => 名前：値
  3. ボディ：リソースの表現そのもの
- レスポンスメッセージ
  1. ステータスライン：プロトコルバージョン＋ステータスコード＋テキストフレーズ
  2. ヘッダ：メタデータ => 名前：値
  3. ボディ：リソースの表現そのもの

#### 6-6. HTTPのステートレス性
- ステートフル
  - サーバーがクライアント状態を覚えている
  - メッセージは簡潔
  - 欠点：スケールアウト（規模拡大）が難しい
  - 利点：通信エラーへの対処が可能

- ステートレス
  - サーバーがクライアント状態を覚えていない
  - メッセージは冗長
  - 利点：スケールアウトが簡易
  - 欠点：パフォーマンスの低下（データ量多、認証が多）、通信エラーへの対処が不確実

※HTTPは『シンプル』ゆえに大きく普及した

### 第7章 HTTPメソッド
#### 7-1. HTTPメソッド
1. GET    ：リソースの取得
2. POST   ：子リソース作成、リソースのデータ追加、その他
3. PUT    ：リソースの作成、更新
4. DELETE ：リソースの削除
5. HEAD   ：リソースのヘッダ取得
6. OPTIONS：リソースがサポートしているメソッドの取得
7. TRACE  ：自分宛てにリクエストを繰り返す（ほとんど使用しない）
8. CONNECT：プロキシ動作のトンネル接続への変更（ほとんど使用しない）

#### 7-2. HTTPメソッドとCRUD
CRUD：CREATE、READ、UPDATE、DELETE
- CREATE：POST／PUT
- READ：GET
- UPDATE：PUT
- DELETE：DELETE

#### 7-3. GET
1. 指定したURIの情報を取得：レスポンス 200 OK

#### 7-4. POST
1. 子リソースの作成：レスポンス 201 Created
2. リソースへのデータ追加：レスポンス 200 OK
3. 他のメソッドでは対応できない処理：検索わーどをボディに埋め込むなど

#### 7-5. PUT
1. リソースの更新：レスポンス 200 OK
2. リソースの作成：レスポンス 201 Created

#### 7-6. POSTとPUTの使い分け
- POST：URI指定不可
- PUT ：URI指定可（サーバーとの結合が密）

=> 基本的にはPOSTを使用しサーバー側でURI等を管理するのが望ましい

#### 7-7. DELETE
1. リソースの削除：レスポンス 200 OK

#### 7-8. HEAD
1. リソースのヘッダの取得

#### 7-9. OPTIONS
1. リソースがサポートしているメソッドの取得

#### 7-10. HTMLのフォームの制約
- HTMLのフォームで指定可能：GET、POSTのみ
- POSTでPUT／DELETEを代用する必要あり
  1. _methodパラメータ<br>
    POSTのボディ部分に_method=PUT&body=<br>
    ※Ruby on Railsで採用
  2. X-HTTP-Method-Override<br>
    フォーム以外（XML等）で利用<br>
    X-HTTP-Method-Override:PUT をヘッダに記述

#### 7-11. べき等性と安全性
- べき等性：何度やっても結果が変わらない
- 安全性：何度やっても内容が変わらない
  - べき等かつ安全：GET、HEAD
  - べき等だが安全でない：PUT、DELETE
  - べき等でも安全でもない：POST

### 第8章 ステータスコード
#### 8-1. ステータスコードの分類と意味
- 1xx：処理中
- 2xx：成功
- 3xx：リダイレクト
- 4xx：クライアントエラー
- 5xx：サーバーエラー

#### 8-2. よく使われるステータスコード
- 200 OK                    ：リクエスト成功
- 201 Created               ：リソースの作成成功
- 301 Moved Permanently     ：リソースの恒久的な移動
- 303 See Other             ：別URIの参照
- 400 Bad Request           ：リクエストの間違い
- 401 Unauthorized          ：アクセス権不正
- 404 Not Found             ：リソースの不在
- 500 Internal Server Error ：サーバー内部エラー
- 503 Service Unavailable   ：サービス停止

#### 8-3. ステータスコードとエラー処理
プロトコルに使ったフォーマットでエラーを返す => API等では親切

### 第9章 HTTPヘッダ
HTTPヘッダはe-mailのヘッダの仕様を参考に作成された
#### 9-1. 日時
- リクエスト／レスポンス：Date
- リクエスト
  1. if-Modified-Since：条件付きGETでリソースの更新日時を指定
  2. If-Unmodified-Since：DELETEでリソースの更新日時を指定
- レスポンス
  1. Expires：レスポンスをキャッシュできる有効期限
  2. Last-Modified：リソースを最後に更新した日時
  3. Retry-After：再リクエストを送信できる目安

#### 9-2. MIMEメディアタイプ
- Content-Type：タイプ/サブタイプ
- Charset     ：文字エンコーディングの指定

#### 9-3. 言語タグ
- Content-Langage: jp-JP（言語コード-地域コード）

#### 9-4. コンテントネゴシエーション
- Accept：処理できるメディアタイプを伝える
- Accept-Charset：処理できる文字エンコードを伝える
- Accept-Langage：処理できる言語を伝える

#### 9-5. Content-Lengthとチャンク転送
- Content-Length：10進数バイト（ボディの長さを指定する）
- Transfer-Encording: Chunked：チャンク転送（ボディを分割して少しづつ転送）

#### 9-6. 認証
- Basic認証：ユーザー名、パスワード認証方式
  Authorization: Basic xxxxxxxxxxxx <= ユーザー名:パスワードをBase64エンコード
- Digest認証：Digestはメッセージダイジェストの略 <= ハッシュ関数を適用した結果のハッシュ値を利用
  1. ユーザー名:realm:パスワード => MD5でハッシュ値
  2. メソッド:URI => MD5でハッシュ値
  3. 1の値:サーバーからのnonce:クライアントがnonceを送った回数:クライアントが生成したnonce（Cnonce）:qop:2の値 => MD5でハッシュ値
  4. クライアントがresponseフィールドに入れて送信
  - 利点：ハッシュ値をDBに登録（セキュア）
  - 欠点：nonceが必要なため毎リクエストごとに認証が必要 <= 普及しない理由
- WSSE認証：HTTP1.1標準外の認証、APIなどで利用

##### 9-7. HTTPとHTTPS
- HTTPSはHTTPとSSL/TLSを組み合わせた総称（デフォルトポート:443番）
- SSL/TLSの機能
  - 暗号化
  - 認証
  - 改ざん検知

##### 9-8. OpenIDとOAuth
- OpenID：シンプルなシングルサインオン => 他のサービスIDでログイン
- OAuth：Webサービス間での認可の委譲

#### 9-9. キャッシュ
- ソースをローカルストレージにためて再利用

##### 9-10. キャッシュ用ヘッダ
- Pragma: no-chche：キャッシュ不可
- Expires: 日時：有効期限を示す
- Cache-Control

##### 9-11. 条件付きGET
- if-Modified-Since:リソースの更新日時
- if-None-Match:ETag <= リソース更新されると値が変わる

#### 9-12. 持続的接続
- HTTP1.1ではデフォルト設定
- HTTP1.0ではKeep-Aliveヘッダで実現
- パイプライン化：持続的接続ではレスポンスを待たずに同じサーバーにリクエスト送信が可能（効率的にメッセージ処理が可能）
- Connection: closeのヘッダで切断

#### 9-13. その他のヘッダ
- Content-Disposition：ファイル名を指定する
- Slug：ファイル名のヒントを指定する

## 第4部 ハイパーメディアフォーマット
### 第10章 HTML
HTML4.01の内容 => 現在はHTML5になり、一部内容は古くなっている

### 第11章 microformats
現在でもあまり普及はしていない

### 第12章 Atom
現在、かなり廃れてしまった

### 第13章 AtomPub
一部、ブログサービスAPIとして運用 => ブログサービスがWordPressへ移行したため、状況が大きく変わった

### 第14章 JSON
#### 14-1. JSON
- JSON：JavaScript Object Notation
- JavaScriptの記法で記述されたシンプルなデータフォーマット：Ajax通信等で利用
- メディアタイプ：Applicaion/json 基本はUTF-8を使用
- 拡張子：.json

#### 14-2. データ型
- オブジェクト
- 配列
- 文字列
- 数値
- ブーリアン：true,false
- null
- 日時：JavaScriptで処理した値
- リンク：URIを文字列で持つのがシンプル

#### 14-3. JSONPによるクロスドメイン通信
- Ajax通信 => XMLHttpRequestのJavaScriptモジュールを利用 <= JavaScriptを取得したサーバーのみ通信可能
- 解決策
  1. HTMLのheaderで\<script>を使い複数のJavaScriptを読み込む
  2. コールバック関数を活用するJSONP<br>
    オリジナルJSONをクライアント指定のコールバック関数でラップ<br>
    複数個所にアクセスを行う

## 第5部 Webサービスの設計
### 第15章 読み取り専用のWebサービスの設計

#### 15-1. リソース指向アーキテクチャ
1. Webサービスで提供するデータを特定する
2. データをリソースに分ける
3. リソースにURIで名前を付ける
4. クライアントに提供するリソースの表現を設計する
5. リンクとフォームを利用してリソース同士を結び付ける
6. イベントの標準的なコースを検討する
7. エラーについて検討する

### 第16章 書き込み可能なWebサービスの設計
#### 16-1. 機能
- リソースの作成
- リソースの更新
- リソースの削除
- バッチ処理
- トランザクション
- 排他的制御

##### 16-2. リソースの作成
- POST：ファクトリリソースによる作成
- PUT：クライアントから作成

##### 16-3. リソースの更新
- PUTで更新が普通
  - バルクアップデート：全部のデータを送信
  - パーシャルアップデート：差分のみ送信

##### 16-4. リソースの削除
- URIを指定しDELETE

##### 16-5. バッチ処理
- POSTで複数のデータを送り、一括処理

##### 16-6. トランザクション
- 複数の処理が終了することを保証
- 途中でエラーなら元のまま

##### 16-7. 排他的制御
- 悲観的ロック：クライアントを信用しないロック
- 楽観的ロック：条件付きGET等でコンフリクト発生時のみ対応

### 第17章 リソースの設計
#### 17-1. リソース指向アーキテクチャ
- 関係モデルからの導出
- オブジェクト指向からの導出
- 情報アーキテクチャからの導出
