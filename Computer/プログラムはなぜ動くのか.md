# プログラムはなぜ動くのか
## 第1章 プログラマにとってCPUとはなにか
- CPU（Central Processing Unit）
  - レジスタ：命令やデータを格納
  - 制御装置：メモリ上の命令やデータをレジスタに読みだす等制御
  - 演算装置：レジスタのデータを演算
  - クロック：動作タイミング

- メモリ：メイン・メモリー（主記憶）
  - CPUとは制御用ICを介して接続
  - アドレス（番地）：1バイト（＝8ビット）ごと
  - CPUはここからアドレスを指定してデータを読む
  - 電源を消すとデータは消える

- プログラム：レジスタを対象として記述される
  - CPUはレジスタの集合体
  - 主なレジスタの種類とその役割
|レジスタの種類|役割|
|---|---|
|アキュームレジスタ|演算を行うデータおよび演算後のデータを格納する|
|フラグ・レジスタ|演算処理後のCPUの状態を格納する|
|プログラム・カウンタ|次に実行する命令が格納されたメモリーのアドレスを格納する|
|ベース・レジスタ|データ用のメモリ領域の先頭アドレスを格納|
|インデックス・レジスタ|ベースレジスタからの相対アドレスを格納する|
|汎用レジスタ|任意のデータを格納する|
|命令レジスタ|命令そのものを格納する。プログラマがプログラムでこのレジスタの値を読み書きするのではなく、CPUが内部的に使用する|
|スタック・レジスタ|スタック領域の先頭アドレスを格納する|

- アセンブリ言語（アセンブラ）
  - マシン語命令にニーモニック（動作を表す英語の略語）を付加
  - マシン語と1対1で対応
  - アセンブル：アセンブリ言語→マシン語
  - 逆アセンブル：マシン語→アセンブリ言語

- プログラム
  - 高水準言語 → コンパイル → マシン語 → CPU → レジスタを使った処理
  - レジスタに格納される値
    - 命令
    - データ
  - データ
    - 演算に使われる値
    - メモリーのアドレスを表す値
  - プログラム・カウンタ
    - プログラムの流れを決める
    - フラグ・レジスタの結果を元にジャンプ命令 → 条件分岐、繰り返し
    - フラグ・レジスタ：正、ゼロ、負
  - プログラムの流れ
    - 順次振興
    - 条件分岐
    - 繰り返し
  - 関数呼び出し
    - コール命令：次の命令をスタックに保存
    - リターン命令：スタックに保温されたアドレスをプログラムカウンタに設定
  - 配列
    - ベース・レジスタ、インデックス・レジスタをメモリー領域を区切って使用

- CPUにできること
  - マシン語命令の主な種類と機能
|種類|機能|
|---|---|
|データ転送命令|レジスタとメモリー、メモリーとメモリー、レジスタと周辺装置の間でデータを読み書きする|
|演算命令|アキュムレータで算術演算、論理演算、比較演算、シフト演算を行う|
|ジャンプ命令|条件分岐、繰り返し、無条件のジャンプに使う|
|コール／リターン命令|関数を呼び出す／呼び出し元に戻る|

- 問題
  - プログラムとは、何ですか？
    - コンピュータに実行させる処理の順番を示すもの
  - プログラムの中には、何が含まれていますか？
    - 命令とデータ
  - マシン語とは、何ですか？
    - CPUが直接解釈できる言語
  - 実行時のプログラムは、どこに格納されていますか？
    - メモリー（メイン・メモリー）
  - メモリーのアドレスとは、何ですか？
    - メモリー上で命令やデータが格納されている場所を示す値
  - コンピュータの構成要素の中で、プログラムを解釈・実行する装置は何ですか？
    - CPU

## 第2章 データを2進数でイメージしよう
- コンピュータ ← ICで構成
  - 0/1（L/H）で情報を表す
  - ビット：2進数一桁
  - バイト：8桁の2進数

- 2進数 → 10進数
  - 1100 = 2^3 * 1 + 2^2 * 1 + 2^1 * 0 + 2^0 * 0
  - 重み：○○の××乗
  - 基数：↑の○○

- シフト演算
  - 左シフト：2,4,8倍
  - 右シフト：1/2,1/4,1/8倍

- 2進数でマイナスを表す
  - 最上位桁：符号ビット 0→正、1→負
  - コンピュータは減算も加算で行う → 2の補数

- 2の補数：プラス値でマイナス値を表す
  - 全ての桁を反転し、1を加える
  - 1 = 00000001、-1 = 11111111 => 1-1 = 00000000
  - 整数型：-32768～32767、0～32767 とマイナス側が多いのは2の補数のため

- シフト演算と符号拡張
  - 左シフト：空いた桁に0
  - 右シフト：空いた桁に0
  - 2の補数：符号ビットで上位桁を埋める

- 演算
  - 算術演算：四則演算
  - 論理演算
    - NOT（否定）：反転
    - AND（論理積）：両方が1の場合のみ1
    - OR（論理和）：どちらか一方が1の場合1
    - XOR（排他的論理和）：両方が異なる場合のみ1
    - 真理値表

- 問題
  - 32ビットは、何バイトですか？
    - 4バイト
  - 01011100という2進数は、10進数でいくつになりますか？
    - 92
  - 00001111という2進数を2桁左シフトすると、元の数を何倍したことになりますか？
    - 4倍
  - 2の補数表現で表された8桁の2進数11111111は、10進数ではいくつになりますか？
    - -1
  - 2の補数形式で表された8桁の2進数10101010を、16桁の2進数で表すとどうなりますか？
    - 1111111110101010
  - グラフィックスパターンを部分的に反転させるためには、何という論理演算を使いますか
    - XOR（排他的論理和）

## 第3章 コンピュータが小数点の計算を間違える理由
- 0.1 × 100 = 10にならない
- 小数点以下を2進数で表す
  - 1011.0011 = 2^3 * 1 + 2^2 * 0 + 2^1 * 1 + 2^0 * 1 + 2^-1 * 0 + 2^-2 * 0 + 2^-3 * 1 + 2^-4 * 1  
  - 小数部分 0.5、0.25、0.125、0.0625の重みとなる
  - 小数点以下4桁の2進数で表せる数
|2進数|10進数|
|---|---|
|0.0000|0|
|0.0001|0.0625|
|0.0010|0125|
|0.0011|0.1875|
|0.0100|0.25|
|0.0101|0.3125|
|0.0110|0.375|
|0.0111|0.4375|
|0.1000|0.5|
|0.1001|0.5625|
|0.1010|0.625|
|0.1011|06875|
|0.1100|0.75|
|0.1101|08125|
|0.1110|0.875|
|0.1111|0.9375|

  - 0.1は3進数では循環小数（10進数の1/3と同じ）

- 浮動小数点数
  - 倍精度浮動小数点数（64ビット）
  - 単精度浮動小数点数（32ビット）

- 浮動小数点数の表現
  - 式：± m × n^e
    - 符号
    - 仮数：m → 小数点以上の値を1に固定する正規表現
    - 基数：n = 2
    - 指数：e → イクセス（excess）表現
  - 倍精度浮動小数点数：符号：1ビット、指数：11ビット、仮数部：52ビット
  - 倍精度浮動小数点数：符号：1ビット、指数：8ビット、仮数部：23ビット

- 正規表現とイクセス表現
  - 小数点以上の値を1に固定する正規表現
    - 1011.0011 → 1.0110011 → 1.0110011000...23ビット → 0110011000 小数点以下のみ
  - イクセス表現：指数部で表せる中央値を0とし、符号を使わないでマイナス値を表現
|実際の値|10進数|イクセス表現|
|---|---|---|
|1111111|255|128|
|1111110|254|127|
|0111111|127|0|
|0111110|126|1|
|0000000|1|-126|
|0000001|0|-127|

- コンピュータの計算間違いを回避するには
  - 浮動小数点数で取り扱うため
    - 間違いを無視する：精度が必要ない時
    - 小数点数を整数に置き換えて計算する：BCD（Binary Coded Decimal）など
  - 桁あふれについては別

- 2進数と16進数
  - 2進数：桁が多いとみにくい
  - 16進数：2進数4桁ごとに表せるので読み換えしやすい

- 問題
  - 2進数の0.1は、10進数でいくつですか？
    - 0.5
  - 小数点以下3桁の2進数で、10進数の0.625を表せるでしょうか？
    - 0.101
  - 小数点数を符号、仮数、基数、指数という4つの部分に分けて表す形式を何と呼びますか？
    - 浮動小数点数
  - 2進数の基数は、いくつですか？
    - 2
  - 表せる範囲の中央の値を0とみなすことで、符号ビットを使わずにマイナスの値を表す方法を何と呼びますか？
    - イクセス表現
  - 10101100.01010011という2進数は、16進数でいくつですか？
    - AC.53

## 第4章 四角いメモリーを丸く使う
- メモリーIC
  - 電源：VCC、GND
  - アドレス信号：A0～A9 1024B = 1KB  
  - データ信号：D0～D7 ← 8ビット
  - 制御信号：RD、WR

- メモリーのイメージはビルディング
|アドレス|メモリーの内容|
|---|---|
|0000000000|1バイトのデータ|
|0000000001|1バイトのデータ|
|0000000010|1バイトのデータ|
|..........|...............|
|1111111110|1バイトのデータ|
|1111111111|1バイトのデータ|

- ポインタ：データが格納されているメモリーのアドレスを持つ変数

- メモリーを工夫して使う
  - 配列

- 配列
  - 同じデータ型（サイズ）の複数のデータがメモリー内に連続して並んだもの
  - インデックス（添字）：配列の要素となるデータを区別する、先頭からの通し番号
  - メモリーの使い方の基本 = メモリーの物理構造と同じだから

- スタックとキュー：アドレス、インデックスを指定せずに配列の要素に読み書きできる
  - スタック：LIFO（Last In First Out：後入れ先出し）
    - Push、Pop
  - キュー：FIFO（First In First Out：先入れ先出し） → 待ち行列
    - EnQueue、DeQueue
    - リング・バッファという形態で使われるのが一般的

- リスト
  - 配列の個々の要素にデータ値、次の要素のインデックスを保持
  - インデックスの順番とは関係なく読み書き可能

- 二分探索木（バイナリー・サーチ・ツリー）
  - 効率的なデータ検索が可能
  - 配列に追加する時に大小関係のインデックス情報を持つ

- 問題
  - アドレス信号を10本持ったメモリーICで指定できるアドレス範囲は、いくつですか？
    - 0～1023 （1024B = 1kB ）
  - 高水準言語のデータ型は、何を表すものですか？
    - メモリー領域を占有するサイズと格納されるデータ型
  - 32ビットでメモリー・アドレスを表す環境では、ポインタとなる変数のサイズは何ビットですか？
    - 32ビット
  - 物理的なメモリーの構造と同様なのは、何バイトのデータ型の配列ですか？
    - 1バイト
  - LIFO方式でデータを読み書きするデータ構造を何と呼びますか？
    - スタック
  - データの大小に応じてリストが2方向に枝分かれするデータ構造を何と呼びますか？
    - 二分探索木

## 第5章 メモリーとディスクの親密な関係
- ストアド・プログラム方式（プログラム内蔵方式）
  - 記憶装置に格納されたプログラムを順次読み出して実行する
  - ディスク → メモリ → CPU

- ディスク・キャッシュ
  - 一度読み出されたデータ保存しておくメモリー領域
  - 最近は効果が少なくなっている
  - キャッシュの技術はブラウザなどでも使用されている

- 仮想記憶
  - ディスクをメモリーの一部として使う
  - ページング方式：Windows
  - セグメント方式

- SSD（Solid State Drive）
  - メモリをディスクとして使う

- メモリを節約するプログラミング手法
  - DLL（Dynamic Link Library）ファイル
    - 共有化で高効率化
  - _stdcall呼び出し
    - スタックのクリーンアップ処理 → コンパイラがやってくれる

- ディスクの物理構造
  - セクター方式：一般的
  - バリアブル方式

- 問題
  - ストアド・プログラム方式とは何のことですか？
    - 記憶装置にプログラムを格納し、逐次実行する方式
  - メモリーを使ってディスクのアクセス速度を向上させる仕組みを何と呼びますか？
    - ディスク・キャッシュ
  - ディスクの一部を仮想的にメモリーとして使う仕組みを何と呼びますか？
    - 仮想記憶（仮想メモリー）
  - Windowsにおいて、プログラムの実行時に、動的に結合される関数やデータを格納したファイルを何と呼びますか？
    - DLL（Dynamic Link Library）ファイル
  - プログラムのEXEファイルの中に、関数を静的に結合することを何と呼びますか？
    - スタティック・リンク
  - Windowsパソコンにおいて、一般的なハードディスクの1セクターは、何バイトですか？
    - 512バイト

## 第6章 自分でデータを圧縮してみよう
- ファイル：バイト単位で記録

- ランレングス法（Run Length Encoding）
  - データ×繰り返し回数で表す
  - 繰り返しが多い画像ファイルには良い
  - テキストファイルには不向き

- ハフマン法：ZIP形式の元
  - ハフマン木を使って符号体系を構築する
  - 全てのファイルで圧縮率が高い

- 可逆性と非可逆性
  - 可逆圧縮：圧縮前の状態に戻る
  - 非可逆圧縮：圧縮前の状態に戻らない

- 画像ファイル
  - BMP形式：圧縮なし
  - JPEG形式：非可逆圧縮
  - GIF形式：可逆圧縮、色が256色限定
  - PNG形式：可逆圧縮

- ファイルにデータが記憶される基本単位は、何でしょうか？
  - バイト
- doc、zip、txtの中で、圧縮ファイルの拡張子であるものは、どれでしょうか？
  - zip
- ファイルの内容を「データの値×繰り返し回数」で表すことで圧縮する技法は、ランレングス法、ハフマン法のどちらでしょうか？
  - ランレングス法
- Windowsパソコンでよく使われるシフトJISコードという文字コードでは、半角英数の1文字を何バイトのデータで表すでしょうか？
  - 1バイト（8ビット）
- BMP形式の画像ファイルは、圧縮されているでしょうか？
  - されていない
- 可逆圧縮と非可逆圧縮の違いは、何でしょうか？
  - 可逆圧縮は圧縮前の状態に戻せる、非可逆圧縮は圧縮前の状態に戻せない

## 第7章 プログラムはどんな環境で動くのか
- 動作環境：OS + ハードウェア
- CPU
  - Windows：x86系
  - MIPS
  - SPARC
  - PowerPC
- マシン語：ネイティブ・コード
- テキストファイル：ソース・コード

- API（Application Programming Interface）
  - アプリケーションからOSへの命令のやり方を定めたもの
  - OSごとにAPIは異なる

- CPUが異なると同じネイティブ・コードが再利用できない
- Linux：ソースコードを選びコンパイルして使用することも可能
- Java（Write once, run anywhere）
  - プログラミング言語
  - プログラム実行環境（Java仮想マシン = Java Virtual Machine）
    - コンパイル → バイトコード → JavaVM → ネイティブコード
    - 互換性は完全ではない
    - 実行速度が遅い

- クラウドとして提供される仮想的な実行環境
  - SaaS（Softwere as s Service）：アプリ提供
  - PaaS（Platform as a Service）：OS提供
  - IaaS（Infrastructure as a Service）：ハードウェア提供

- BIOSとブート・ストラップ
  - BIOS（Basic Input/Output System）：ROMに記憶され、コンピュータに内蔵
    - キーボード、ディスク装置、ブート・ストラップ・ローダーなど
  ｰ ブート・ストラップ：OS起動

- 問題
  - アプリケーションの動作環境は、何で示されますか？
    - OS ＋ ハードウェア
  - Windows用アプリケーションは、そのままmacOS上で動作するでしょうか？
    - できない
  - Windowsパソコン（PC/AT互換機）にWindows以外のOSをインストールできますか？
    - Linuxをインストールできる  
  - Java仮想マシンの役割は、何ですか？
    - バイトコードとなったJavaアプリケーションを実行すること
  - クラウドの分類のSaaS、PaaS、IaaSの中で、仮想的なハードウェアを提供するものはどれですか？
    - IaaS
  - ブート・ストラップ・ローダーの役割は何ですか？
    - OSの起動

## 第8章 ソース・ファイルから実行可能ファイルができるまで
- ソースコード → コンパイラ → ネイティブコード
- クロスコンパイラ：異なるCPU用のネイティブコードも生成可能

- ネイティブコード → 実行ファイルにはならない
  - リンク処理が必要

- ソース・ファイル → コンパイル → 
  - オブジェクト・ファイル
  - +スタートアップ
  - +スタティック・リンク・ライブラリ
  - +インポート・ライブラリ（以上：スタティック・リンク）
  - ダイナミック・リンク・ライブラリ（ダイナミック・リンク）
  - → 実行可能ファイル

- EXEファイルの中身
  - 再配置情報：メモリー・アドレスの変換が必要な部分
  - 変数（データ）のグループ
  - 関数（処理）のグループ
  - ロード時に作成
    - スタック：関数の内部で一時的に使用される変数（ローカル変数）
    - ヒープ：プログラムの実行時に任意のデータを格納するメモリー領域
      - 解放しないとメモリーリーク

- コンパイラーとインタプリタ
  - コンパイラー：実行前に処理
  - インタプリタ：ソースコードを1行づつ処理
- 分割コンパイル：分割したソースコードから1つのEXEファイルを作成する
- ビルド：コンパイルとリンクを続けて行う
- DLLファイルを使うメリット：複数のプログラムで共有し、ディスク、メモリーを節約できる
- インポート・ライブラリをリンクしないとDLLファイルの関数は呼び出せない
  - 呼び出せるが、インポート・ライブラリを使った方が簡単
- オーバーレイ・リンク：同時に実行されない関数を同じアドレスに交替でロードして実行
  - オーバーレイ・リンカーが必要
- ガベージ・コレクション（Garbage Collection）
  - 処理が終わって不要になったヒープ領域を解放するのをプログラムが行ってくれる仕組み
  - メモリー・リークはなくなる

- 問題
  - CPUが解釈・実行できる形式のプログラムを何コードと呼びますか？
    - ネイティブコード
  - 複数のオブジェクト・ファイルを結合してEXEファイルを生成するツールを何と呼びますか？
    - リンカー
  - 拡張子が.objとなったオブジェクト・ファイルの内容は、ソースコードとネイティブコードのどちらですか？
    - ネイティブコード
  - 複数のオブジェクト・ファイルをまとめて収録したファイルを何と呼びますか？
    - ライブラリ・ファイル
  - DLLファイルに格納された関数を呼び出すための情報を持つファイルを何と呼びますか？
    - インポート・ライブラリ
  - プログラムの実行時に、動的に確保されるメモリー領域を何と呼びますか？
    - ヒープ

## 第9章 OSとアプリケーションの関係
- OSの歴史
  - モニター・プログラム：OSの原型
  - モニター・プログラム+基本的な入出力プログラム
  - OSは複数のプログラムの集合体

- OS
  - OSが存在 → ハードウェアを直接制御するプログラムを記述することはない
  - アプリケーション → OS → ハードウェア制御

- システム・コール：OSのハードウェア制御機能
  - 同じソースコードで違うハードウェアを制御できる（移植性が高い）
  - OSがハードウェアを抽象化してくれる

- WindowsというOSの特徴
  - 32ビット版と64ビット版がある
    - 多くのアプリケーションは32ビットで作成（互換性）
  - APIという関数セットでシステムコールを提供する
    - Win32 API
    - Win64 API
  - GUIを採用したUIを提供する
  - WYSIWYG（ウィジィウィグ）によるプリンタ出力ができる
  - マルチタスクを提供する：時分割、マルチスレッド
  - ネットワーク機能やデータベース機能を提供する
    - データベース：ミドルウェア
    - システム・ソフトウェア：OS + ミドルウェア
  - プラグ＆プレイによるデバイス・ドライバの自動設定
    - デバイス・ドライバ：ハードウェアの入出力を行う機能

- 問題
  - モニター・プログラムの主な機能は、何ですか？
    - プログラムのロードと実行
  - OSの上で動作するプログラムのことを何と呼びますか？
    - アプリケーション
  - OSが提供する機能を呼び出すことを何と言いますか？
    - システムコール
  - Windows10は、何ビットOSですか？
    - 32ビット、64ビット
  - GUIとは、何の略語ですか？
    - Graphic User Interface
  - WYSIWYGとは、何の略語ですか？
    - What You See is What You Get

## 第10章 アセンブリ言語からプログラムの本当の姿を知る
- アセンブリ言語
  - ネイティブコードと1対1
  - 構文：オペコード オペランド
    - オペコード：命令の動作
    - オペランド：命令の対象

- 第1章を細かく説明

- 問題
  - アセンブリ言語において、ネイティブ・コードの命令に、その機能を表す英語の略称を付けたものを何と呼びますか？
    - ニーモニック
  - アセンブリ言語のソースコードをネイティブ・コードに変換することを何と呼びますか？
    - アセンブル
  - ネイティブ・コードをアセンブリ言語のソースコードに逆変換することを何と呼びますか？
    - 逆アセンブル
  - アセンブリ言語のソース・ファイルの拡張子は、何ですか？
    - .asm、.s
  - アセンブリ言語のプログラムにおけるセクション（セグメント）とは何ですか？
    - プログラムを構成する命令やデータをまとめたグループのこと
  - アセンブリ言語のジャンプ命令は、何のために使われますか？
    - プログラムの流れを任意のアドレスに移す

## 第11章 ハードウェアを制御する方法
- アプリケーション ← API ← OS ← in命令 ← ハードウェア
- アプリケーション → API → OS → out命令 → ハードウェア

- in命令：指定したポート番号のポートからデータを入力
- out命令：CPUのレジスタに格納されているデータを指定したポート番号のポートに出力

- CPU（レジスタ） ← （ポート）I/Oコントローラ ← キーボード
- CPU（レジスタ） → （ポート）I/Oコントローラ → ディスプレイ

- ポート番号：I/Oアドレス

- IRQ（Interrupt Request）：割り込み要求
  - 実行中のプログラムを停止して、他のプログラムに実行を移す仕組み：割り込み処理
  - 割り込み番号：IRQの機器を特定
  - 割り込みコントローラ：順番にCPUに割り込み処理を伝える
  - ポーリング：常に入力の有無を調べる（PCには不向き）

- DMA（Direct Memory Access）
  - CPUを介さずに周辺機器がコンピュータのメインメモリーとデータの転送を行う
  - DMAコントローラで実現
    - DMAチャネル
    - PIO（Programmed I/O）

- 競合：異なるデバイスに同じポート番号、IRQ、DMAチャネルが割り当てられる

- ディスプレイに表示される仕組み
  - VRAM（Video RAM）
  - グラフィック・ボード：VRAM + GPU（Graphic Processing Unit）

- 問題
  - アセンブリ言語で、周辺装置と入出力を行う命令は何ですか？
    - in命令、out命令
  - I/Oとは、何の略語ですか？
    - Input/Output
  - 周辺装置を識別する番号を何と呼びますか？
    - I/Oポート番号
  - IRQとは、何の略語ですか？
    - Interrupt Request
  - DMAとは、何の略語ですか？
    - Direct Memory Access
  - DMAを行う周辺装置を識別するための番号を何と呼びますか？
    - DMAチャネル

## 第12章 コンピュータに「学習」をさせるには
- 機械学習（Machine Learning）
- 教師あり学習
  - 分類問題
    - 学習データ
    - 教師データ

- サポートベクトルマシン（SVM：Support Vector Machine）

- 機械学習で手書き文字の認識を行う
  - 学習データと教師データを訓練用とテスト用に分ける
  - 訓練用のデータを学習アルゴリズムで学習させて学習済みモデルを作らせる
  - テスト用のデータで学習済みモデルの性能を評価する
- クロスバリデーションをやる
  - 訓練用とテスト用のデータを入れ替え検証

- 機械学習とは、何ですか？
  - コンピュータ自体に学習させること
- 機械学習のテーマのひとつである分類問題とは、何ですか？
  - 与えられたデータを適切に認識して分類すること
- 機械学習のアルゴリズムであるSVMは、何の略語ですか
  - サポートベクトルマシン（SVM：Support Vector Machine）
- 機械学習の分野でPythonがよく使われるのは、なぜですか？
  - 機械学習のためのさまざまな機能がライブラリとして提供されていて、それらの機能をインタプリタで簡単に試せるから
- 分類問題の機械学習の学習器と分類器とは、何ですか？
  - 学習アルゴリズムと学習済みモデル
- 機械学習におけるクロスバリデーションは、日本語に直訳するとどういう意味ですか？
  - 交差検証
