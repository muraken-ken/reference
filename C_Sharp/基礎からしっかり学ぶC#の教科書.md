# 基礎からしっかり学ぶ C#の教科書
## 第1章 プログラミングの基礎
### 1.1 プログラムとは
- プログラミング  
  - 書く：プログラミング
  - 書く人：プログラマ
  - 記述：コード
  - コードを書く：コーディング
- ハードウェアとソフトウェア
  - ハードウェア：変更できない
  - ソフトウェア：変更できる
- アプリケーションとOS
- プログラミングの対象
  - アプリケーション
    - GUI(Graphical User Interface)
    - CUI(Character-based User Interface)
  - ライブラリ
- スタンドアロン型とクライアントサーバー型
  - スタンドアロン型：インストール
  - クライアントサーバー型：Webアプリ
- コンパイラとインタープリター
  - PC ← マシン語 ← アセンブリ言語 ← 高級言語
    - コンパイル型言語：C、Java、C++、C# など
    - インタープリター型言語：JavaScript、Perl、Python、Ruby、PHPなど
  - メリット・デメリット  
|言語|変換|長所|短所|
|---|---|---|---|
|コンパイル型|実行前|実行速度が速い|コンパイル作業が必要|
|インタープリター型|実行時|すぐに実行、柔軟性がある|実行速度が遅い|

- 動的型付けと静的型付け
  - 動的型付け言語（スクリプト言語）：Perl、Python、Ruby、PHP
  - 静的型付け言語：C++、Visual Basic、C#
- オブジェクト指向
  - 抽象化（カプセル化）
    - オブジェクト
      - 属性
      - メソッド
  - オブジェクトとクラス、継承 => オブジェクト指向プログラミング(OOP:Object-Oriented Programming )
- クラスとインスタンス
  - クラス：雛形
  - インスタンス：雛形から生成されたもの
- クラスと継承
  - スーパークラス：親、基底クラス
  - サブクラス：子、派生クラス
- オブジェクト指向プログラミング言語
  - C言語：×
  - C++：△
  - C#、Java、Visual Basic：◎
- その他の考え方
  - 手続き型プログラミング：処理を順番に記述する
  - 宣言型プログラミング：必要な結果を記述する
  - 関数型プログラミング：関数の評価で記述する
  - コードリーディング：コードを読むことも重要

### 1.2 .NET Framework  
- .NET Framework
  - 共通のライブラリ(FCL:Framework Class Library)＋共通の実行環境(CLR:Common Language Runtime)
- CLR:Common Language Runtime
  - 仮想マシン
  - コンパイラ => 共通中間言語(Common Intermediate Language:CLI,IL) => JIT:Just In Time コンパイル => マシン語
- FCL:Framework Class Library
  - WPF、Windowsフォーム：Windows上で実行されるGUIアプリケーション
  - コンソールアプリケーション：コンソール上で実行されるアプリケーション
  - ASP.NET：Webブラウザー経由で利用するWebアプリケーション
- .NET Frameworkを利用できる言語
  - C#
  - Visual Basic
  - C++/CLI：CLRを介さないプログラムが書ける

### 1.3 ソフトウェア開発
- ソフトウェア開発プロセス
  - 1.業務分析：どのような作業が必要かを考える
  - 2.要求定義：必要な作業のうち、何をコンピュータで行うかを決める
  - 3.設計：ソフトウェアの作り方を決める
  - 4.コーディング：実際にコードを書く
  - 5.テストとデバッグ：プログラムの動作をテストし、デバッグする
- 開発プロセス
  - ウォーターフォール型：開発プロセスを1つづつ行う
  - 反復型開発プロセス：開発プロセスを繰り返す（要求を確定させずリリースし、フィードバックで改善）
  - アジャイルソフトウェア開発：コーディングと要求定義、設計が同時進行する
    - プロセスやツールよりも、個人や協調が大切
    - 包括的な文書より、動くソフトウェアが大事
    - 顧客との交渉よりも協調が大事
    - 計画に従うよりも、変化に柔軟に対応することが大切
- コーディング
  - コーディング規約：コード記述のルール
  - テスト：TDD
  - バージョン管理：Gitなど

## C#の基礎 ～はじめてのプログラムを書く
### 2.1 C#とは
- 2000年、.NET Framework用、MicroSoft勢
- C/C++、Delphiをベース
- JIS X 3015

### 2.2 特徴
- .NET Frameworkに対応
- オブジェクト指向言語
- JavaとC++を踏襲

### 2.3 開発可能なアプリケーション
- CUIアプリケーション
- GUIアプリケーション
- Webアプリケーション

### 2.4 統合開発環境
- Visual Studio Community 

### 2.5 C#プログラムの書き方と構造
- コメント
```
  // 1行コメント
  /*
  複数行コメント
  */
```
- クラス：classキーワードを使って宣言、ブロック内に記述する
- ブロック：`{}`で囲まれた領域
- メンバー：クラス中に含まれる要素
  - データ：フィールド／メンバー変数
  - 処理：メソッド
- エントリポイント：プログラムの開始位置

### 2.6 名前空間の基本
- グローバル名前空間：名前空間を明示的に指定していない無名の名前空間
- System名前空間：.NET Frameworkクラスライブラリに含まれる名前空間
- 完全修飾名
```
  System.Console.WriteLine("foo");
  名前空間.クラス名.メソッド
```
- usingディレクティブ
```
  using System;
  Console..WriteLine("foo"); <= Systemを省略できる
```

### 2.7 名前付けの規約
- 識別子の書き方
  - `_`もしくは半角アルファベットで始まる
  - 大文字／小文字は区別
  - 予約語は使えない

## 第3章 変数とデータ型 ～さまざまなデータを扱うには
### 3.1 変数とデータ型
- 変数：変化可能な値の入れ物
- 代入：変数に値を入れる
- 定数：変化しない固定値
- 変数の宣言：命名の規約 => Microsoft MSDN ライブラリ => 先頭小文字のキャメルケース
```
  データ型 変数の名前;
  データ型 変数の名前 = 初期値;  
  データ型 変数の名前 = 初期値, 変数の名前 = 初期値;  
```
- 定数の宣言：先頭大文字のPascal形式（ex：ConstNumber）
```
  const 定数の名前 = 初期値; //初期値は必須
```

### 3.2 組み込みデータ型
||形式||名称|サイズ|範囲|.NET Framework|規定値|
|---|---|---|---|---|---|---|---|
|数値型|整数型|符号付き|sbyte|8|-2\^7～2\^7-1|System.SByte|0|
|数値型|整数型|符号付き|short|16|-2\^15～2\^15-1|System.Int16|0|
|数値型|整数型|符号付き|int|32|-2\^31～2\^31-1|System.Int32|0|
|数値型|整数型|符号付き|long|64|-2\^63～2\^63-1|System.Int64|0|
|数値型|整数型|符号なし|byte|8|0～2\^7-1|System.Byte|0|
|数値型|整数型|符号なし|ushort|16|0～2\^15-1|System.UInt16|0|
|数値型|整数型|符号なし|uint|32|0～2\^31-1|System.UInt32|0|
|数値型|整数型|符号なし|ulong|64|0～2\^63-1|System.UInt64|0|
|数値型|実数型|浮動小数点型|float|32|±1.5×10^-45～±3.4×10^38|System.Single|0.0F|
|数値型|実数型|浮動小数点型|double|64|±5.0×10^-324～±1.7×10^308|System.Double|0.0D|
|数値型|実数型|10進データ型|decimal|128|±1.0×10^-28～±7.9×10^28|System.Decimal|0.0M|
|論理型|||bool|8|true/false|System.Boolean|false|
|文字型|||char|16|0～2^16-1|System.Char|'\0'|
|文字列型|||string|||System.String|null|

- 数値型
  - 整数
    - 10進数：123_0000
    - 16進数：0xff
    - 2進数：0b1111_1010
  - コンパイラ
    - 小数、指数：double型
    - その他：int、uint、long、ulongを自動判別
  - 明示方法
    - unit：123U
    - long：123L
    - ulong：123UL
    - float：1.0F
    - double：1.0D
    - decimal：1.0M
- 論理型（bool型）
  - true（真）
  - false（偽）
- 文字型（char型）：1文字のデータ
  - UTF-16
- エスケープシーケンス
|エスケープシーケンス|説明|
|---|---|
|`\'`|シングルクォーテーション|
|`\"`|ダブルクォーテーション|
|`\\`|円マーク|
|`\0`|null文字|
|`\a`|ビープ音|
|`\b`|バックスペース|
|`\f`|フォームフォワード|
|`\n`|改行|
|`\r`|キャリッジリターン|
|`\t`|水平タブ|
|`\v`|垂直タブ|
|`\uXXXX`|Unicode文字|
- 文字列型（string型）
  - 複数の文字コードが並んだデータ（""）：エスケープシーケンスも使用可
  - 逐語的文字列リテラル（@""）：エスケープシーケンス不要、`"`は`""`と記述

### 3.3 変数の有効範囲
- スコープ：変数の有効範囲 => ブロック単位
  - ローカル変数：メソッドごと
  - メンバー変数：クラスごと

### 3.4 型変換
- 型変換
  - 暗黙的変換：コンパイラ
  - 明示的変換：ユーザー
    - キャスト：明示的な変換が可能（桁あふれ、丸めなどに注意）
    ```
      byte a = 123;
      long b = a;
      byte c = b;       //エラー
      byte c = (byte)b; //キャスト
    ```

### 3.5 値型と参照型
- スタック
  - 値型：int、float、double、decimal、charなど
  - 参照型のアドレス
  - 破棄：スコープ外で破棄
- ヒープ
  - 参照型：stringなど
  - 参照型変数
  - 静的変数 
  - GC（ガベージコレクション）で自動的に削除

### 3.6 ユーザー定義型（UDT:User-Defined Data Type）
- ユーザー定義型
  - 列挙型（値型）：int 0から +1、代入も可能
  ```
    宣言 enum 列挙名:データ型 { ,で区切った列挙子 }
    参照 列挙名.列挙子
  ```
  - 構造体（値型）：関連のある変数を小さなグループとして定義したもの
  ```
    public struct Book
    {
      public decimal price;
      public string title;
      public string author;
    }
  ```
  - 配列（参照型）
  ```
    宣言 データ型[] 配列名;
    宣言＋初期化 データ型[] 配列名 = new データ型[] {値1, 値2,…};
    参照 データ型[インデックス]
  ```

### 3.7 型推論（C#バージョン3.0）
- 型推論（暗黙的型付け）
```
  var i = 5;  //int型
  var s = "Hello!";  //string型
  var a = new[] {0, 1, 2};  //int型配列
```
- 匿名型：名前のない一時的にしか利用しない型を簡単に使える
```
  var a = new { Number = 48, Name = "akiba" };
```
- タプル型

## 第4章 式と演算子 ～計算を表現するには
### 4.1 プログラムを構成するもの
- 式と演算子
```
  式  a = b + 100
  演算子（オペレーター）  +
  オペランド（被演算子）  a, b, 100 <= それぞれが式でもある
```
- 式を評価する：式から値を求める
- 文（ステートメント）：文の終わりは`;`、`{}`ブロックも文
```
  a = b + 100;
  {
    文1;
    文2;
  }
```

### 4.2 演算子
|機能別|演算子|概要|
|---|---|---|
|代入演算子|=|代入|
|算術演算子|+|符号（単項演算子）|
||-|符号の反転（単項演算子）|
||++|インクリメント（1を加算）|
||--|デクリメント（1を減算）|
||+|加算（二項演算子）|
||-|減算（二項演算子）|
||*|乗算|
||/|除算（整数型：余りは切り捨て）|
||%|余剰（除算の余り）|
|比較演算子|==|等しいかどうか|
||!=|異なるかどうか|
||<|左が右より小さいかどうか|
||>|左が右より大きいかどうか|
||<=|左が右以下かどうか|
||>=|左が右以上かどうか|
||!|NOT（否定演算）、bool型のみ|
||&|AND（倫理積）、整数型、bool型のみ|
||\||OR（倫理和）、整数型、bool型のみ|
||^|XOR（排他的倫理和）、整数型、bool型のみ|
||&&|条件AND演算子、bool型のみ|
||\|\||条件AND演算子、bool型のみ|
|条件演算子|?:|三項演算子、条件 ? true : false|
|複合代入演算子|+=|演算結果を、元のデータに代入|
||-=||
||*=||
||/=||
||%=||
||&=||
||\|=||
||^=||
||<<=||
||>>=||
|ビット演算子|~|ビットの反転（補数演算）|
||<<|左シフト|
||>>|右シフト|

### 4.3 演算子の優先順位
|シンボル|操作の種類|結合規則|
|---|---|---|
|[ ] ( ) . -> ++-- (後置)|正規表現|左から右|
|sizeof & * + - ~ ! ++-- (前置)|単項|右から左|
|* / %|乗法|左から右|
|+ -|加法|左から右|
|<< >>|ビットごとのシフト|左から右|
|< > <= >=|関係|左から右|
|== !=|等価比較|左から右|
|&|ビットごとの AND|左から右|
|^|ビットごとの排他的 OR|左から右|
|\||ビットごとの包括的 OR|左から右|
|&&|論理 AND|左から右|
|\|\||論理 OR|左から右|
|? :|条件式|右から左|
|= *= /= %= += -= <<= >>= &= ^= \|=|単純代入と複合代入|右から左|
|,|順次評価|左から右|
※`()`で式の優先順位を分かりやすく書くこと！

### 4.4 参照型の代入と比較
- 参照型の代入：メモリアドレスがコピーされる
- 参照型の比較：参照しているメモリアドレスの比較（string型はデータの比較）

## 第5章 制御文～プログラムの流れを理解する
### 5.1 制御文とは
- 制御文：プログラムの流れ（フロー）を制御するための構文
- 構造化定理  
  - 任意の一入力・一出力は、
    - 順次（sequence）
    - 選択（ifthenelse）
    - 繰り返し（whiledo）
    の３つの基本制御構造からなる関数と等価である
  - 構造化プログラミング

### 5.2 選択
- if文
```
  if (条件式1)
  {
    条件式1がtrueと評価された時の式
  }
  else if (条件式2)
  {
    条件式2がtrueと評価された時の式
  }
  else if (条件式3)
  {
    条件式3がtrueと評価された時の式
  }
  else
  {
    条件式が全てfalseと評価された時の式
  }
```
- switch文
```
  switch (式)
  {
    case ラベル1:
      式の値がラベル1に一致した時の処理
      break;
    case ラベルn:
      式の値がラベルnに一致した時の処理
      break;
    default:
      式の値が全ラベルに一致しなかった時の処理
      break;
  }
```

### 5.3 繰り返し
- forループ：条件式がtrueの間繰り返す
```
  for ( カウンタ変数の初期化; 条件式; カウンター変数の更新 )
  {
    繰り返す処理
  }
```
- whileループ：条件式がtrueの間繰り返す
```
  while (条件式)
  {
    繰り返す処理
  }
```
- doループ：処理後に判定する
```
  do
  {
    繰り返す処理
  }
  while (条件式);
```
- foreachループ
```
  foreach ( データ型 変数 in コレクション )
  {
    繰り返す処理
  }
```

### 5.5 ジャンプ（無条件分岐）
- break文：ループから抜け出す
- continue文：当該処理をスキップ、ループは継続
- goto文：任意のラベルにジャンプ（使わない）
```
  goto ラベル名;
  ラベル名: //switch文のdefaultはラベル
```

## 第6章 クラスの基礎とメソッド～オブジェクト指向への最初のステップ
### 6.1 クラスの基礎
- クラスの定義：データとそのデータに関する処理をまとめて定義したもの
```
  class クラスの名前
  {
    メンバーの定義
  }
```
- メンバー：クラスを構成する要素
  - データメンバー
    - フィールド（メンバー変数）
    - 定数
  - 関数メンバー
    - メソッド
    - コンストラクター
    - デストラクター
    - プロパティ
    - イベント
    - インデクサー
    - 演算子
- クラスのインスタンス化
  - クラスは設計図で実態がない
  - 参照型なので、参照先のアドレスが決まっただけ
  - インスタンス化 => 確保したメモリにクラスのコピーを作る
  ```
    クラス名 変数名 = new クラス名();
  ```
- データメンバーへのアクセス
```
  インスタンス名.メンバー名 //.は「ドット演算子」
                            //.メンバー名は、インスタンスメンバー
```

### 6.2 アクセス修飾子
- アクセス修飾子：アクセス制限のレベル設定
```
  アクセス修飾子 データ型 変数名;
  アクセス修飾子 データ型 変数名 = 初期値;
  アクセス修飾子 const データ型 定数名 = 初期値;
```
|アクセス修飾子|レベル|
|---|---|
|private|同じクラス内に制限|
|public|アクセス制限なし|
|protected|同じクラス、派生クラスに制限|
|internal|同じアセンブリに制限|
|protected internal|同じアセンブリ、派生クラスに制限|

### 6.3 メソッド
- メソッドの定義
```
  アクセス修飾子 戻り値の型 メソッド名(パラメータのリスト)
  {
    メソッドの本体
  }
```
- 戻り値の型：データ型、何も返さない場合 => voidキーワード
- パラメータ：引数
- メソッドの呼び出し
```
  インスタンス名.メンバー名(パラメータリスト);  //インスタンスメソッド
  クラス名.メンバー名(パラメータリスト);        //静的メソッド
```
- メソッドの戻り値
```
  return 戻り値;
```
※戻り値の有無（void）であるかどうかに注意
- メソッドのパラメーター
  - 実パラメーター：メソッド呼び出しの際に指定
  - 仮パラメーター：メソッド宣言時に指定
- 名前付きパラメーター
  - 利点：宣言の順番通りでなくても良い
  ```
    パラメーター名:値
  ```
- 省略可能なパラメーター（デフォルト値）
```
  宣言 メソッド名(データ型 仮パラメーター = 規定値)
```
- 可変パラメーター：パラメータ数が任意に可変可能
```
  宣言 戻り値のデータ型 メソッド名( params データ型[] パラメーター名 )
  {
    メソッド本体
  }
```
  - paramsパラメーターは1つまで
  - 他のパラメータと同時に指定可能だが、paramsは右端にする
- 値渡し（call by value）  
  - 特に指定しなければ、値渡しとみなされる
  - 元の値はそのまま（非破壊的）
- 参照渡し（call by reference）
```
  宣言 メソッド名( ref データ型 パラメーター名 )
  {
    メソッド本体
  }
  呼び出し インスタンス名.メソッド名( ref パラメータ名 )
```
  - 格納先の値も更新される（破壊的変更）
- 参照による戻り値の定義
```
  宣言 ref データ型 メソッド名( ref データ型 パラメーター名 )
  {
    メソッド本体
    return ref 戻り値名;
  }
  呼び出し ref インスタンス名.メソッド名( ref パラメータ名 )
  ref データ型 変数名 = ref インスタンス名.メソッド名( ref パラメータ名 ) //参照渡しで変数に代入も可
```
- outキーワード（参照渡し）
  - return文：一つのオブジェクトのみ（構造体を使用すれば複数可能）
  - out文：複数のオブジェクトを返すことが可能
  ```
    宣言 データ型 メソッド名( int a, out データ型 パラメータ名1, out データ型 パラメータ名1 )
    {
      メソッド本体
     }
    呼び出し インスタンス名.メソッド名( 3, out パラメータ名1,  out パラメータ名2 )
  ```
- メソッドのオーバーロード
  - オーバーロード：パラメータリストだけが異なる、同じ名前の複数のメソッドを定義可能
  - 自動的に適切なメソッドが呼び出される
- thisキーワード
  - クラスの現在のインスタンスを参照：メンバー名を指定メンバー名とパラメータ名を区別できる
  ```
    class ClassThis
    {
      int num;

      public void SetNum( int num )
      {
        num = num;      //どちらのnumかわからない
        this.num = num; //メンバーのnumに代入している
      }
    }
  ```
- ローカル関数
  - ローカル関数：メソッドの中で定義された関数
  - 定義されているメソッド内でしか利用できない

### 6.4 インスタンス
- コンストラクター：クラスの初期化（省略可）
```
  class Car
  {
    //データメンバー
    public string name;
    public int seats;
    //コンストラクター
    public Car()  //クラス名と同じ
    {
      seats = 4;  //seatsを４で初期化
    } 
  }
```
  - パラメーター付コンストラクターも可能
  - 既定コンストラクター：パラメーターのないコンストラクター
- デストラクター
  - インスタンスが消滅する際に呼び出されるメソッド
  - 基本的に使わない：GCがいつインスタンスを消去するかわからないため
  ```
    ~Car()
    {
      処理
    }
  ```

### 6.5 インスタンスメンバーと静的メンバー
- インスタンスメンバー：インスタンスに属するメンバー（他のインスタンスに影響しない）
- 静的メンバー：クラスに属するデータメンバーなど（全インスタンスに影響する）
  - メソッド、コンストラクター、プロパティ、演算子、イベントも定義可能
- 静的フィールド（staticキーワード）
```
  class Car
  {
    public string name;       //インスタンスメンバー
    public static int seats;  //静的メンバー
  }
```
```
  呼び出し（インスタンス内） seats
  呼び出し（インスタンス外） クラス名.seats
```
- 静的メソッド（staticキーワード）
```
  class Car
  {
    public static int seats;  //静的メンバー
    public static void SetSeat( int n )
    {
      seats = n;  //静的メンバーのみ
    }
  }
  呼び出し Car.SetSeat( 5 );
```
- 静的コンストラクター
```
  class Car
  {
    public static int seats;  //静的メンバー
    public Car()
    {
      seats = 4;  //静的メンバーのみ
    }
  }
```
  - アクセス修飾子やパラメーターは指定できない
  - 静的コンストラクターを直接呼び出すことはできない
  - 複数のクラスがある場合でも、呼び出されるタイミングを制御することはできない
- 静的クラス：インスタンスを作成せずにアクセスできるデータや処理
```
  static class ClassStatic
  {
    public static int a;
    static ClassStatic()
    {
      a = 5;
    }
    public static void Display()
    {
      Console.Writeline( a );
    }
  }
  class MainClass
  {
    static void Main()
    {
      ClassStatic.Display();  //出力値：5
    }
  }
```

## 第7章 継承とカプセル化～クラスの機能を変更するには
### 7.1 継承
- 継承（inheritance）：あるクラスを土台として新たなクラスを作る（機能拡張）
  - 基本クラス（ベースクラス）：継承元のクラス
  - 派生クラス：新しいクラス
  - 単一継承のみ
  - 構文
  ```
    class 基本クラス名 { 処理 }                 //基本クラスの定義
    class 派生クラス名 : 基本クラス名 { 処理 }  //派生クラスの定義
  ```
- 継承とコンストラクター
  - 処理の順番
    - インスタンスメンバーの初期化
    - 基本クラスのコンストラクターの呼び出し
    - 派生クラスのコンストラクターの呼び出し
- コンストラクター初期化子
```
  派生クラスのコンストラクター(パラメーター) : base(基本クラスに渡すパラメーター) {}
  class BaseClass
  {
    public BaseClass( string s )
    {      
    }
  }
  class DeriveClass : BaseClass
  {
    class DeriveClass( string s1, string s2 ) : base( s2 )
    {}
  }
```
  - コンストラクター初期化子でのthis（継承とは無関係）
  ```
    public SampleClass( int x, string s )
    {    
    }
    public SampleClass( int x ): this(x, "規定値")
    {      
    }
  ```
- 隠蔽：基本クラスを派生クラスで再定義
```
  class BaseClass
  {
    int type = 0;
  }
  class DeriveClass : BaseClass
  {
    new int type = 1; //newキーワードを付ける
  }
```
  - 基本クラスへのアクセス
  ```
    base.type //baseキーワード
  ```
- オーバーライド
```
  class BaseClass
  {
    public virtual void method()  //virtualキーワード
    {
    }
  }
  class DeriveClass : BaseClass
  {
    public override void method() //overrideキーワード
    {
    }
  }
```

### 7.2 カプセル化
- カプセル化：複雑な処理をオブジェクトの内部に隠し、外部からは公開された手段のみでアクセスできるようにする
  - アクセス修飾子による制限
- プロパティ
  - アクセサー：フィールドをカプセル化してメソッドのみでアクセスできるように制限したメソッド
  ```
    アクセス修飾子 データ型 プロパティ名
    {
      set { フィールド名 = value; } //代入
      get { return フィールド名; }  //参照
    }
  ```
- 自動プロパティ：下記の1行で下記の内容にコンパイルされる
```
  public string Name { get; set; }
```
```
  private string __name
  public string Name
  {
    get { return this.__name; }
    set { this.__name = value; }
  }
```
- 自動プロパティの初期化子（Auto-propaty initializers）
```
  データ型 プロパティ名 { get; set; } = 初期値;
```
- オブジェクト初期化子
```
  new クラス名 { メンバー1 = 初期値, メンバー2 = 初期値, … };
```
- インデクサー：配列のように値にインデックスでアクセスできる
```
  アクセス修飾子 戻り値の型 this{ 添え字の型 添字 }
  {
    set {}
    get {}
  }
```
```
  [添字] = 初期値;
```

### 7.3 パーシャルクラス
- パーシャルクラス：クラスを分割定義できる
```
  class Sample
  {
    int a =1;
    public test()
    {
      Console.WriteLine(a);
    }
  }
```
```
  partial class Sample
  {
    int a = 1;
  }
```
```
  partial class Sample
  {
    Console.WriteLine(a);
  }
```
- パーシャルメソッド：メソッドの宣言と定義を分けて記述できる
  - パーシャルクラス内のメソッドに限られる
  - privateのみ
  - 戻り値はvoidのみ
  - パラメーターでoutキーワードは使用不可
  ```
    partial class Sample
    {
      static partial void LogInfo();
      static void Main()
      {
        LogInfo();
        Console.WriteLine( "Hello" );
      }
    }
  ```
  ```
    partial class Sample
    {
      static partial void LogInfo();
      static void Main()
      {
        Console.WriteLine( "debug" );
      }
    }
  ```

## 第8章 ポリモーフィズム～クラスを操作するには
### 8.1 ポリモーフィズム（多態性）
- ポリモーフィズム：同じメソッドを複数のクラスで使用できるようにする
- 型変換
  - アップキャスト：派生クラスから基本クラスへのキャスト（変換）=> 暗黙的
  - ダウンキャスト：基本クラスから派生クラスへのキャスト（変換）=> 明示的
    - is演算子：ダウンキャスト可能か診断
    ```
      変数名 is クラス名  //true/false
    ```
    - as演算子：ダウンキャストを実行し、できない場合はnullを返す
    ```
      変数名 as クラス名
    ```
- オブジェクト型とボックス化  
C#：System.Objectクラスが全てのクラスの基本クラス
  - ボックス化：値型→Objectへ変換
  - ボックス化解除：Object→値型へ変換
  ```
    static void Main()
    {
      int a = 5;
      object obj;
      obj = a;          //ボックス化
      int b = (int)obj; //ボックス化解除
    }
  ```
- オーバーライドのしくみ
  - インスタンスに応じて、呼び出される仮想メソッドが決まる：ポリモーフィズム
- 隠蔽との違い
  - オーバーライド：アップキャストすると派生クラスの再定義が有効
  - 隠蔽（newキーワード）：アップキャストしても派生クラスの再定義が無効
- 抽象メソッドと抽象クラス
  - 抽象メソッド：戻り値の型とパラメータリストだけを宣言したメソッド（abstractキーワード）
  ```
    アクセス修飾子 abstract 戻り値の型名 メソッド名( パラメータリスト );
  ```
  - 抽象クラス：抽象メソッドを含むクラス
  ```
    アクセス修飾子 abstract class クラス名
    {
      //クラス定義
    }
  ```
  - 抽象クラスを継承したクラス：オーバーライドが必要
  ```
    class DeriveClass : BaseClass
    {
      public override void メソッド名
      {
        //処理
      }
    }
  ```
- sealedキーワード：継承禁止
```
  アクセス修飾子 sealed class クラス名
  {
    //クラス定義
  }
```

### 8.2 インターフェイス
- インターフェイスとは：メソッドの呼び出し方だけを定めたもの
  - インターフェイスを実装する：継承したクラスで処理を定義
```
  interface インターフェイス名
  {
    //抽象メンバーの宣言
  }
```
```
  interface IGetInfo
  {
    void getInfo();
  }
  class SampleClass : IGetInfo
  {
    public void GetInfo()
    { //処理 }
  }
  class MainClass
  {
    static void Main()
    {
      SampleClass s = new SampleClass();
      s.GetInfo();
    }
  }
  ```
- データ型としてのインターフェイス：プロパティを含んだインターフェイス
```
  interface IPoint
  {
    int Px
    { get; set; }
    int Py
    { get; set; }
  }
  class ReversePoint : IPoint
  {
    int x;
    int y;
    public RevwersePoint( int x, int y )
    { 
      this.x = x
      this.y = y
    }
    public int Px
    {
      get { return -x; }
      set { x = value; }
    }
    public int Py
    {
      get { return -y; }
      set { y = value; }
    }
  }
```
- インターフェイスの多重継承と多重実装
  - インターフェイスがインターフェイスを継承できる
  - 複数のインターフェイスを継承できる
  ```
    interface インターフェイス名 : 基本インターフェイス1, 基本インターフェイス2
    {
      //抽象メンバーの宣言
    }
  ```
- 明示的なインターフェイスメンバーの宣言
```
  インターフェイス名.メソッド名(パラメーターリスト)
  {
    //インターフェイスの実装
  }
```
### 8.3 型スイッチ
- is演算子の拡張（判定 + 定義）
```
  変数 is 型 変数名
```
```
  if ( m is Song s )
  {
    s.メソッド名
  }
```
- switch文の拡張
```
  case 型 変数名:
  case 型 変数名 when 条件式:
```
```
  static void Main ( string[] args )
  {
    object obj = "visual";
    switch ( obj )
    {
      case int n:
        //処理
        break;
      case string str when str.Length > 3:
        //処理
        break;
    }
  }
```

## 第9章 例外処理～思いがけないことに対処するには
### 9.1 例外処理とは
- 例外：コンパイルでエラーにならず、実行中に検知された異常
- 例外がスローされる：例外が発生する
- キャッチ（補足する）：例外を検知する
- 例外処理：例外をキャッチして適切な処理を行う

### 9.2 try - catch - finally
- try - catch
```
  try
  {
    //例外を検出したい処理
  }
  catch
  {
    //例外が発生したときに行う処理
  }
```
- try - catch -finally
```
  try
  {
    //例外を検出したい処理
  }
  catch
  {
    //例外が発生したときに行う処理
  }
  finally
  {
    //終了処理（例外の有無に関係なし）
  }
```
- try - finally：例外が発生した時点でfinallyの処理が実行される
```
  try
  {
    //例外を検出したい処理
  }
  finally
  {
    //終了処理（例外の有無に関係なし）
  }
```

### 9.3 例外クラス
- catchブロック
```
  catch( 例外クラス 変数名 )
  {
    //例外時処理
  }
```
- System.Exceptionクラスのプロパティ
|プロパティ名|内容|
|---|---|
|Source|アプリケーションまたはオブジェクトの名前を取得または設定|
|Message|説明するメッセージを取得|
|HelpLink|ヘルプ ファイルへのリンクを取得または設定|
|Data|ユーザー定義情報を提供する、キーと値のペアのコレクションを取得|
|StackTrace|呼び出し履歴で直前のフレームの文字列形式を取得|
|InnerException|原因となる Exception インスタンスを取得|
|TargetSite|例外がスローされたメソッドを取得|
|HResult|割り当てられているコード化数値である HRESULT を取得または設定|
- 特定の例外のキャッチ
```
  catch( DivideByZeroException 変数名 )
  {
    //ゼロ除算例外の補足時処理
  }
```
- 例外フィルター
```
  catch( 例外クラス 変数名 ) when ( 条件式 )
  {
    //例外時処理
  }
```
- .NET Frameworkで定義された例外クラス（System.Exception）
  - System.OutOfMemoryException：プログラムの実行を継続するためのメモリが不足している場合にスローされる例外
  - System.NullReferenceException：null オブジェクト参照を逆参照しようとした場合にスローされる例外
  - InvalidCastException：無効なキャストまたは明示的な変換が発生したときにスローされる例外
  - ArrayTypeMismatchException：誤った型の要素を配列内に格納しようとした場合にスローされる例外
  - IndexOutOfRangeException：境界外のインデックスを使用して配列またはコレクションの要素にアクセスしようとしたときにスローされる例外
  - ArithmeticException：キャスト演算または変換演算にエラーがあった場合にスローされます
    - DivideByZeroException：整数または Decimal 値を 0 で除算しようとするとスローされる例外
    - OverflowException：checked コンテキストの算術演算、キャスト演算、または変換演算でオーバーフローが発生するとスローされる例外
  - System.IO.IOException：I/O エラーが発生したときにスローされる例外
- ユーザー定義の例外クラス
  - カスタム例外
  ```
    class CustomException : Exception
    {
      public CustomException( string msg ) : base( msg )
      {
      }
    }
  ```

### 9.4 throw文  
ユーザー定義の例外はthrow文を使用してスローすることができる
- 例外の再スロー：catchブロック内から再び例外をスローする  
ひとつ外側のcatchブロックにしか再スローすることができない

### 9.5 checked文とunchecked文
- オーバーフローは発生しても例外は発生しない：コントロールできるようになっている
  - オーバーフローの例外を強制的にスロー
  ```
    checked
    {
      //オーバーフローの例外を検出したい処理
    }
  ```
  - オーバーフローの例外を強制的に無視
  ```
    unchecked
    {
      //オーバーフローの例外を検出したくない処理
    }
  ```

## 第10章 配列と構造体～データをまとめて扱うには
### 10.1 配列
- 配列の基礎
```
  データ型[] 配列名;
  データ型[] 配列名 = new データ型[配列数];
  データ型[] 配列名 = new データ型[] {値1, 値2,};
```
- 多次元配列
```
  データ型[,] 配列名 = new データ型[要素数, 要素数];
```
- 配列のプロパティ
  - 配列のサイズ
  ```
    配列名.Length
  ```
  - 配列の次元
  ```
    配列名.Rank
  ```
  - 配列の次元ごとのサイズ
  ```
    配列名.GetLength(次元)
  ```
- ジャグ配列：配列の中身のサイズが異なる、配列の中の配列
```
  データ型[][] 配列名 = new データ型[配列の数][];
  配列名[インデックス] = new データ型[配列のサイズ];
```
- System.Arrayのメソッド
  - Clear：配列内にある要素の範囲を、各要素の型の既定値に設定
  - Sort：配列を昇順に並び替える
  - Reverse：配列の要素を反転させる
  - BinarySearch：ソート済みの配列に対して高速な検索を行う

### 10.2 構造体
- 構造体とは
  - 特殊な形のクラス。異なるデータ型の複数のデータをまとめて扱う
  - 値型（クラスは参照型）
  - 継承できない
- 構造体の定義
```
  struct 構造体名
  {
    //メンバーの定義
  }
```
- 構造体の定義（インターフェイスの実装）
```
  struct 構造体名 : インターフェイス名
  {
    //メンバーの定義
  }
```
- コンストラクター：インスタンス化も可能でコンストラクターを使える
- 組み込みデータ型と構造体
  - ボックス化、ボックス化解除が可能
  - メソッドのパラメータや戻り値として活用できる
  - ref、outキーワードを付けたパラメータとして使用できる

### 10.3 タプル
- タプル：構造体より汎用的に利用できるデータ型
- 匿名型：LINQで利用を目的（immutableなオブジェクト）
```
  new { メンバー1 = 初期値1, メンバー2 = 初期値2, … }
```
- タプル型：mutableなオブジェクト
```
  ( 型 メンバー1, 型 メンバー2, … )
```
- タプル型のリテラル
```
  ( 値1, 値2, … )
  ( メンバー1:値1, メンバー2:値2, … )
```
- タプルの分解
```
  ( string name, int age ) = GetMember();
  ( var name, var age ) = GetMember();    //型推論
  var ( name, age ) = GetMember();        //型推論
  ( _, int age ) = GetMember();           //不要な値は_で受ける
  Console.WriteLine( name );              //個別出力
  Console.WriteLine( age );               //個別出力
```
- タプルの代入：メンバーの型の並びが同じ、暗黙的変換が可能な場合
```
  ( int n, string name ) t1 = ( 1, "foo" );
  ( int num, string str ) t2 = ( 3, "bar" );
  t1 = t2;
  Console.WriteLine( t1.name );
```

### 10.4 null
- null許容型：nullが扱える
```
  データ型? 変数名;
```
```
  int? x = null;
  x.HasValue：true/false
  x.Value：値/例外
```
- ??演算子：null合体演算子
```
  int? a = null;
  Console.WriteLine( a ?? 10 ); //10
  Console.WriteLine( a ?? "Empty" ); //Empty
  a = 5;
  Console.WriteLine( a ?? 10 ); //5
```
- ?.演算子：インスタンスや構造体で使用可
```
  string n = t.Member?.Name;  //nullでなければ値、nullならnull、例外はスローされない
  string n = t.Member.Name;   //nullなら例外がスローされる
```

## 第11章 高度なプログラミング～プログラミングの世界を広げる
### 11.1 デリゲート
- デリゲート型：戻り値の型、パラメータリストが同一
  - メソッド1（インスタンスメソッド、静的メソッド、パラメーターに使える）
  - メソッド2
  - メソッド3
```
  delegate 戻り値の型 デリゲート型名(パラメータリスト);
```
```
  SampleDel delVar = new SampleDel( testMethod );
  SampleDel delVar = testMethod;
```
- メソッドの追加と削除
  - メソッドの追加
  ```
    SampleDel delVar1 = t.TestMethod1;
    SampleDel delVar2 = t.TestMethod2;
    delVar = delVar1 + delVar2
  ```
  ```
    Sample delVar = t.TestMethod1;
    delVar += t.TestMethod2;
  ```
  - メソッドの削除
  ```
    delVar -= t.TestMethod1;
  ```
- 匿名メソッド：デリゲートの定義でメソッドそのものを記述
```
  delegate(パラメータリスト)
  {
    //デリゲートに登録する処理
  }
```

### 11.2 ラムダ式
- ラムダ式の定義：匿名メソッドを簡略した記述が可能
```
  //匿名メソッド
  MyDel del = delegate( int x ) { return x + 1; };
  //ラムダ式
  MyDel del = x => x + 1;
```
  - ラムダ式（式形式）
  ```
    (入力パラメーター) => 式
  ```
  - ラムダ式（ステートメント形式）
  ```
    (入力パラメーター) => {処理;}
  ```
  - `Action<int>`：戻り値のないパラメーター１つの汎用デリゲート
- 変数のキャプチャ
  - ラムダ式では、スコープ外の変数にもアクセス可能
  - 外部変数のキャプチャ：上位スコープの変数を参照している時、ラムダ式が有効なら変数へアクセス可
- ラムダ式によるメンバーの記述  
ラムダ式でクラスのメンバーの本体を記述できる
- throw式（ラムダ式の機能ではない）
  - ラムダ式の=>演算子の後
  - null合体演算子の後
  - 条件演算子の第2または第3引数

### 11.3 イベント
- イベント：プログラムが直接コントロールしないアクション（事象）
  - イベントドリブン（イベント駆動）
  - イベントハンドラー：イベントに対応する処理
- C#のイベント
```
  event デリゲート型名 イベント名;
```
- イベントとデリゲートの違い
  - イベントハンドラーを呼び出せるのは、そのイベントをメンバーとするクラスの内部からだけ
  - 外部からイベントに対して行える操作は、イベントハンドラーの追加と削除のみ

### 11.4 非同期処理
- 同期処理（synchronous）：プログラムの上から順番に実行される処理
- 非同期処理（asynchronous）：複数の処理が並列に実行される
  - 並列処理（concurrent）：1つの処理を分割して同時に実行する
  - 平行処理（parallel）
- スレッド（Thread）：プログラムの最小の実行単位
- プロセス（Process）：OS上でプログラムを起動するとき作られる仮想的な領域
  - スレッド単位で動作しており、1つ以上のスレッド（メインスレッド）が含まれる
- マルチスレッド処理：非同期に複数のスレッドで処理
- .NET Framework：System.Threading名前空間 Threadクラス
- Thread：現在は直接触らない
- ThreadPool：現在は直接触らない
- タスク（Task）：Thread、ThreadPoolクラスを統合したクラス
- パラレル（Parallel）クラス：処理を並列に実行できるクラス
- async修飾子とawait演算子
```
  async Task メソッド名()
  {
    awaitタスクオブジェクト;
  }
```

### 11.5 名前空間
- 名前空間の定義
```
  namespace 名前
  {
    //クラスや名前空間の定義
  }
```
```
  namespace Window
  {
    namespace Drawing
    {
    }
  }
  namespace Window
  {
  }
  namespace Window.Drawing
  {
  }
```
- using