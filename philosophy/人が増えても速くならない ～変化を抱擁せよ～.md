# 人が増えても速くならない ～変化を抱擁せよ～
## 1章　完成しても，終わりではない
- 疑問：依頼は画面の一部を変更するだけなのに、どうして簡単に見通せないのだろう

### システムは使い始めてから改善が始まる
- システムは目的を達成して導入すれば良い：間違い
- 導入がスタート地点：正しい
  - 状況の変化に対応していく必要がある
    - 新たな要望
    - 使い勝手の改善
    - データ量
    - 要件の変化 etc

### なぜ，ソフトウェアなのに固くなってしまうのか
- 行きあたりばったりで改修を加えてしまう
  - 複雑性が増す => 混乱の極み
- 一度きりの完成を目指してしまう
  - 事前にしっかりと考える（要件を固める）=> 完成後のことが未考慮

### プロジェクトからプロダクトの考え方に変える
- 従来：システムを完成させて導入するプロジェクト
- 今後：システムを事業のコアとして、事業を成長させるように考える（プロダクト）
  - 仮説を立て、試行錯誤を繰り返す
  - 依頼して作るもの => 協働して一緒に作るもの

## 2章　人を増やしても速く作れるわけではない
- 疑問：人を増やしたので、生産性は上がるはずなのに

### 2倍の予算があっても2倍の生産性にはならない
- 製造現場：人を増やせば生産量が上がる
- ソフトウェア開発：短期的に見れば相関はない
  - ソフトウェアエンジニアの仕事
    - 設計されたものをコーディングする仕事：間違い
    - 求められている機能をどういったプログラムで表現するかを考える仕事

### 遅れているプロジェクトに人を追加するのはやめて
- あとから入った人の情報や知識のキャッチアップと、その人たちへの教育にコストがかかる
  - 元からいた人の生産性が落ちる
- 関わる人数が増えると、メンバー同士でのコミュニケーションにかかる時間が増えてしまう
  - 人が増えるとミーティング、相談なども増える
  - 一緒に長くやっているとコストは少ないが、最初はすり合わせにコストがかかる
  - 長期的に見れば生産性は上がる
- タスクを物界するにも限界がある
  - 細かすぎるタスクに分解するより、自分でやった方が速い

### 銀の弾丸はないが"金の弾丸"なら有効なときがある
- 既にいる人の生産性を高める
  - 高い生産性を出せるような環境を用意する
    - 性能の良いPC
    - AIのサポート
- クラウドに移行したうえで、クラウドの性能を増強する
- 金の弾丸：お金で解決できることはやるのも有効

### 速く作ることはできないが，速く作れるチームは作れる
- 人海戦術では速くならず、金の弾丸は根本対策にならない
- 速く作ることのできるチームは作れる
  - チームワーク
  - コミュニケーション
  - 心理的安全が高い
  - 信頼感
  - チームビルドには時間が必要、都度解散しては無理

### チームの哲学や文化が揃っていることが大事
- 特に経験豊富なエンジニア同士は大事
- 速く作れるチームは貴重な財産

## 3章　たくさん作っても生産性が高いとは言えない
- 疑問：ちょっとした機能を作るのにこんなに時間がかかるのだろうか

### あらゆる状況を考慮するのに時間がかかる
- 仕様書に沿ってプログラミングするだけ：間違い
- コンピュータはプログラム通りにか動かない
  - プログラムを書く人間が考慮できていない動きはできない
  - エンジニアはあらゆるケースでのあらゆる処理を考慮する（時間がかかる）

### プログラムは現実の理解の上に成り立つ
- プログラマが知りたいのは、現実世界のこと（背景）
  - 社内システム：業務内容
  - ユーザー向けサービス：動線やビジネスモデル
- 優れたエンジニア
  - プログラムに詳しい ＋ 業務やサービスについての知識と理解がある
  - 事業のビジョン、目的、会社のミッションも考慮する
  - 誰にでもできる仕事ではない
- 依頼する時に大事なこと
  - 機能の内容 ＋「その機能がなぜ必要なのか」＋「事業にとっての意味」

### 影響範囲に気をつけて，重複をなくすことも仕事
- 新しいプログラムを作成するより、既存のプログラムを修正することが多い
  - 既存のプログラムを理解した上で、機能を追加する
  - 論理的に整合性が求められる
  - 似たような機能を重複して作ると後の変更で変更箇所が増えて大変
- プログラムは必ず読み返される
  - 動くだけでなく、読みやすく書かなけらばならない
  - 読みにくいと生産性が大きく損なわれる  

### 同じソフトウェアを複数人で同時改修するのは非効率
- 整合性と一貫性が必要となるので、複数人での開発は注意が必要
- 作っているソフトウェアを分ける
  - Amazon：Two Pizzas Team（２つのピザを分け合える人数が良い）

### 生産性は，手を動かした時間で測らない
- プログラムを書いた量で生産性を測るのはNG
  - ベタ書きプログラムより、抽象化したプログラムが良い（コード量は逆）
- 機能数で評価するのもNG
  - ソフトに求めていたものは、効率化、行動や習慣の変化
  - 機能の数では上記は変わらない
- ビジネスや状況が変化したとき
  - 図体の大きいソフトウェアは機敏に動けない
  - シンプルで小さなソフトウェアでいた方が、不具合も少なく、変化への対応も容易
- ソフトウェアは小さく、シンプルがベスト

## 4章　人に依存せず同じ品質で作ることはできない
- 疑問：データ構造や設計がいけていない、美しくないと生産性にどういう関係が

### ソフトウェアは一品モノ，1つずつ中身が違う
- 工業製品：同じものを大量に作る
- ソフトウェア：小説を書く、作曲すると似ている

### 外から見える品質と，見ることのできない品質
- ソフトウェアの品質
  - 外から見える品質（サービスの提供者、利用者にとって重要）
    - 見た目の良さ
    - 不具合がないか
    - 遅くないか
    - 操作は簡単か
  - 外から見えない内部品質
    - 誰にでも理解しやすく作られているか
    - 後から修正を加えることを考慮されているか
- ハードウェア：不良品は交換で済む
- ソフトウェア：交換することはできないので、品質は更に重要になる

### エンジニアにしかわからないプログラムの美しさ
- 内部品質：後々の生産性に影響する
  - 散らかって道具がバラバラな部屋での作業は生産性が上がらない
  - 一覧化や数値化して把握することが容易でない
  - シンプルさや読みやすさには正解がなく、人により異なる

### クリエイティブな仕事の属人化を解決する
- 標準化や手順書の整備では解決できない
- コードレビューの実施を徹底して、チーム内の成果と知見を高める

## 5章　プレッシャーをかけても生産性は上がらない
- 疑問：納期を急がせた後、生産性が落ちた気がする

### 急がせたところで速く作ることはできない
- 一時的な生産性を上げるために「作り方」で妥協させると後々の生産性に影響する

### 一時的な妥協は，永遠の負債になる
- 一時的に妥協した品質は、あとから簡単にリカバリーはできない
  - 修正時に読みにくい部分がある場合、そこを作り直す必要が出てくる（コストがかかる <= そういうコストは払いたくないので実現しない）
  - そのまま機能を積み重ねると、これ以上機能を追加するのに手を出せない状態となる
- 妥協は、借金や負債のようなもの「技術的負債」
  - 技術的負債は、放置すればするほど利子のように膨らみ返済のコストが大きくなる
  - 一度乱雑にしてしまったものをシンプルに戻すのは不可能
- 最初からずっとシンプルに作り続けることが最善手
  - プログラムをシンプルに保つためのコストと期間は必要なものとして、最初から計画に織り込んでおく

### 作れば作るほど，生産性は落ちていく
- ソフトウェアや機能は、一度作ってしまえば、後は動かし続けるだけなので人手はかからない：間違い
  - 運用（アクセス数、データ量の変化対応など）
  - 不具合対応（開発が必要な場合もある）
  - バージョンアップ（かなりの工数が必要）
  - ユーザーのヘルプ

### 生産性が上がる仕組みを作ることは投資
- バージョンアップ等のコスト：動作確認のテスト
  - コンピュータによるテストの自動化は不可欠
  - 自動テストを作るコストは投資

### 楽をするための苦労はいとわない
- 目の前の生産性を上げるか ＜ 生産性を上げる仕組みを作る
- ふりかえり：仕事のやり方やプロセスを見直す

## 6章　見積もりを求めるほどに絶望感は増す
- 疑問：ざっくり見積もるとどれくらいか知りたいのになかなか答えが出ない

### なぜ，正確な見積もりが出せないのか
- ざっくり見積りは、超難しい
  - 詳細まで仕様を把握できなかった
  - 例外的な処理を把握しきれなかった
  - 想定していた技術が使えなかった
  - 人によりばらつきがある
- 正確な見積りはやってみると同じになる

### 見積もりを守るためのバッファの功罪
- ざっくり＝約束的なニュアンスが強く、出しにくい
- 守れる見積もりを出すと最大限にリスクを考慮した数値になる
- 余裕を持って作ったスケジュールはその通りになる（パーキンソンの第一法則）

### 見積もりと約束が"受発注"の関係を作ってしまう
- 見積り＝約束が、発注＝受注の関係を作る
  - 発注側：エンジニアの仕事がわからないので、正確な見積りを求める（損をしたくない）
  - 受注側：依頼されたものを期限内に作るが目的になる
- 本来の目的：より良いシステムを作るから乖離する 

### 事業側と開発側が"協働"の関係を築く
- 協働
  - 事業側：ソフトウェアの特性を知ったうえでシステムの構造や開発のプロセスを理解する
  - 開発側：言われたものを作るだけでなく、システムがどう使われるかを理解する
- 共通のゴールを目指す同じチームとして仕事をする
  - 大きな機能の見積りはあくまで見通し
  - １〜２週間で作れる単位で進捗を確認しながら進める
  - 期間ありきで機能を見積もる
  - エンジニアには、事業活動の目的、ビジョンから共有
  - エンジニアには、何を作るかを決める前に何を実現したいのかから相談
  - 使ったシステムはすぐに使いフィードバックを得る

### 「納品」をなくせばうまくいく（ココは著者の会社の宣伝）

## 7章　一度に大きく作れば得に見えて損をする
- 疑問：進捗がわからない、プロジェクトの終わりが見えない

### プロジェクトが大きくなるとうまくいきにくいのに，なぜプロジェクトは大きくなってしまうのか
- プロジェクトが大きくなると失敗の確率が増す
- プロジェクトが大きくなる理由
  - 構想：大きな夢を詰め込みがち
  - 夢に水を差すような言動は言いにくい
  - 機能が多くなると本当にその機能が必要かを見極めがしずらくなる
- 工業製品生産は数のメリットがあるが、ソフトウェアは大きく開発するメリットはない

### ソフトウェア開発はギャンブルのようなもの，大きく賭けると大きく失敗する
- ソフトウェア開発＝不確実性との戦い
- 一度の失敗で全てを失う賭け方はせず、何度もできるように小さく賭ける

### 小さくすれば不確実さを下げられる
- 失敗のリスクを下げられる
- 不確実さを下げられる

### 小さく作って，大きく育てられるのがソフトウェア
- 後から機能を追加するのは難しいだろう：間違い
  - ソフトウェアの特性を活かした開発になっていなかったから
  - ソフトウェアはシンプルに保てば、機能の追加が可能
  - 早い段階で触れることで、本当の要望に気がつける

### プロジェクトを小さくするために，作ろうとする機能の範囲を限定する
- 確実性を増すためにプロジェクトを小口化していく（機能の範囲を限定する）

### 不確実な未来を，少しずつ確実なものにしていく
- プロジェクトや開発体制の分割時に保守や運用も含めた体制にする
- 優先順位を決め、スコープを狭め、不確実性を下げた状態で進め、動いたら将来の計画を見直す
- 近い未来は解像度を高く、遠い未来は曖昧なまま：ゴーイングコンサーンと呼ばれる会社経営と同じ

## 8章　工程を分業しても，効率化につながらない
- 疑問：専門性を持たせた分業体制にすれば生産性は上がるのでは？

### 工程を分離しても生産性は上がらない
- 工業、製造業では当たり前
- ソフトウェアの分業：ウォーターフォール（製造業を参考に考案）
  - 要件定義、分析、設計、実装、テストの開発と保守、運用も分離
  - 稼働後に変更がない場合は良いが、そんなケースはあり得ない
- 分業するより、同じメンバーが一貫して開発する方が良い

### 猫の手を借りても生産性は上がらない
- ソフトウェア：手を動かすだけの仕事（雑用）がほぼない
  - 雑用：自動化される
  - 数ヶ月で慣れてできる仕事ではない：クリエイティブな仕事
- 初心者のコードレビューは大変
  - 教育は生産性とはっきり分けて行う必要がある

### プログラムは最も低い品質に引っ張られる
- 設計・製造というより、全てが設計

### ソフトウェアの設計はだれのものか
- 一番はソフトウェアを欲しい人がソフトウェアを開発すること
- 次点は、ソフトウェアが欲しい人と開発者が一緒に仕事をすること
